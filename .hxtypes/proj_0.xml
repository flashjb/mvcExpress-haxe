<haxe>
	<class path="Array" params="T" file="/usr/lib/haxe/std/Array.hx" extern="1">
		<filter public="1" set="method"><f a="f">
	<f a="">
		<c path="Array.T"/>
		<x path="Bool"/>
	</f>
	<c path="Array"><c path="Array.T"/></c>
</f></filter>
		<map public="1" params="S" set="method"><f a="f">
	<f a="">
		<c path="Array.T"/>
		<c path="map.S"/>
	</f>
	<c path="Array"><c path="map.S"/></c>
</f></map>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="Array.T"/></t></f>
			<haxe_doc>Returns an iterator of the Array values.</haxe_doc>
		</iterator>
		<copy public="1" set="method">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>Returns a shallow copy of [this] Array.
		
		The elements are not copied and retain their identity, so
		a[i] == a.copy()[i] is true for any valid i. However, a == a.copy() is
		always false.</haxe_doc>
		</copy>
		<remove public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurence of [x] in [this] Array.
		
		This operation modifies [this] Array in place.
		
		If [x] is found by checking standard equality, it is removed from [this]
		Array and all following elements are reindexed acoordingly. The function
		then returns true.
		
		If [x] is not found, [this] Array is not changed and the function
		returns false.</haxe_doc>
		</remove>
		<insert public="1" set="method">
			<f a="pos:x">
				<x path="Int"/>
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Inserts the element [x] at the position [pos].
		
		This operation modifies [this] Array in place.
		
		The offset is calculated like so:
			
		- If [pos] exceeds [this].length, the offset is [this].length.
		- If [pos] is negative, the offset is calculated from the end of [this]
		Array, i.e. [this].length + [pos]. If this yields a negative value,
		the offset is 0.
		- Otherwise, the offset is [pos].
		
		If the resulting offset does not exceed [this].length, all elements from
		and including that offset to the end of [this] Array are moved one index
		ahead.</haxe_doc>
		</insert>
		<unshift public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds the element [x] at the start of [this] Array.
		
		This operation modifies [this] Array in place.
		
		[this].length and the index of each Array element increases by 1.</haxe_doc>
		</unshift>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of [this] Array.
		
		The result will include the individual elements' String representations
		separated by comma. The enclosing [ ] may be missing on some platforms,
		use Std.string() to get a String representation that is consistent
		across platforms.</haxe_doc>
		</toString>
		<splice public="1" set="method">
			<f a="pos:len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc><![CDATA[Removes [len] elements from [this] Array, starting at and including
		[pos], an returns them.
		
		This operation modifies [this] Array in place.
		
		If [len] is < 0 or [pos] exceeds [this].length, the result is the empty
		Array [].
		
		If [pos] is negative, its value is calculated from the end	of [this]
		Array by [this].length + [pos]. If this yields a negative value, 0 is
		used instead.
		
		If the sum of the resulting values for [len] and [pos] exceed
		[this].length, this operation will affect the elements from [pos] to the
		end of [this] Array.
		
		The length of the returned Array is equal to the new length of [this]
		Array subtracted from the original length of [this] Array. In other
		words, each element of the original [this] Array either remains in
		[this] Array or becomes an element of the returned Array.]]></haxe_doc>
		</splice>
		<sort public="1" set="method">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<x path="Int"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sorts [this] Array according to the comparison function [f], where
		[f(x,y)] returns 0 if x == y, a positive Int if x > y and a
		negative Int if x < y.
		
		This operation modifies [this] Array in place.
		
		The sort operation is not guaranteed to be stable, which means that the
		order of equal elements may not be retained. For a stable Array sorting
		algorithm, haxe.ds.sort.MergeSort.sort() can be used instead.
		
		If [f] is null, the result is unspecified.]]></haxe_doc>
		</sort>
		<slice public="1" set="method">
			<f a="pos:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Creates a shallow copy of the range of [this] Array, starting at and
		including [pos], up to but not including [end].
		
		This operation does not modify [this] Array.
		
		The elements are not copied and retain their identity.
		
		If [end] is omitted or exceeds [this].length, it defaults to the end of
		[this] Array.
		
		If [pos] or [end] are negative, their offsets are calculated from the
		end	of [this] Array by [this].length + [pos] and [this].length + [end]
		respectively. If this yields a negative value, 0 is used instead.
		
		If [pos] exceeds [this].length or if [end} exceeds or equals [pos],
		the result is [].</haxe_doc>
		</slice>
		<shift public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the first element of [this] Array and returns it.
		
		This operation modifies [this] Array in place.
		
		If [this] has at least one element, [this].length and the index of each
		remaining element is decreased by 1.
		
		If [this] is the empty Array [], null is returned and the length remains
		0.</haxe_doc>
		</shift>
		<reverse public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[Reverse the order of elements of [this] Array.
		
		This operation modifies [this] Array in place.
		
		If [this].length < 2, [this] remains unchanged.]]></haxe_doc>
		</reverse>
		<push public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Adds the element [x] at the end of [this] Array and returns the offset
		it was added at.
		
		This operation modifies [this] Array in place.
		
		[this].length increases by 1.</haxe_doc>
		</push>
		<pop public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the last element of [this] Array and returns it.
		
		This operation modifies [this] Array in place.
		
		If [this] has at least one element, [this].length will decrease by 1.
		
		If [this] is the empty Array [], null is returned and the length remains
		0.</haxe_doc>
		</pop>
		<join public="1" set="method">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representation of [this] Array, with [sep] separating
		each element.
		
		The result of this operation is equal to Std.string(this[0]) + sep +
		Std.string(this[1]) + sep + ... + sep + Std.string(this[this.length-1]).
		
		If [this] is the empty Array [], the result is the empty String "". If
		[this] has exactly one element, the result is equal to a call to
		Std.string(this[0]).
		
		If [sep] is null, the result is unspecified.</haxe_doc>
		</join>
		<concat public="1" set="method">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns a new Array by appending the elements of [a] to the elements of
		[this] Array.
		
		This operation does not modify [this] Array.
		
		If [a] is the empty Array [], a copy of [this] Array is returned.
		
		The length of the returned Array is equal to the sum of [this].length
		and [a].length.
		
		If [a] is null, the result is unspecified.</haxe_doc>
		</concat>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of [this] Array.</haxe_doc>
		</length>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Array.</haxe_doc>
		</new>
		<haxe_doc>An Array is a storage for values. You can access it using indexes or
	with its API. On the server side, it's often better to use a [List] which
	is less memory and CPU consuming, unless you really need indexed access.</haxe_doc>
	</class>
	<abstract path="Class" params="T" file="/usr/lib/haxe/std/Class.hx">
		<haxe_doc>An abstract type that represents a Class.
	
	See [Type] for the haXe Reflection API.</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Enum" params="T" file="/usr/lib/haxe/std/Enum.hx">
		<haxe_doc>An abstract type that represents an Enum type.
	
	The corresponding enum instance type is EnumValue.
	
	See [Type] for the haXe Reflection API.</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="EnumValue" params="" file="/usr/lib/haxe/std/EnumValue.hx">
		<haxe_doc>An abstract type that represents any enum value.
	See [Type] for the haXe Reflection API.</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<class path="Main" params="" file="src/Main.hx">
		<main public="1" set="method" line="17" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":keep"/></meta>
		</main>
		<new public="1" set="method" line="9"><f a=""><x path="Void"/></f></new>
	</class>
	<abstract path="Map" params="K:V" file="/usr/lib/haxe/std/Map.hx">
		<from>
			<c path="haxe.ds.StringMap"><c path="fromStringMap.V"/></c>
			<c path="haxe.ds.IntMap"><c path="fromIntMap.V"/></c>
			<c path="haxe.ds.ObjectMap">
				<c path="fromObjectMap.K"/>
				<c path="fromObjectMap.V"/>
			</c>
		</from>
		<to>
			<c path="haxe.ds.StringMap"><c path="Map.V"/></c>
			<c path="haxe.ds.IntMap"><c path="Map.V"/></c>
			<c path="haxe.ds.EnumValueMap">
				<c path="toEnumValueMapMap.K"/>
				<c path="Map.V"/>
			</c>
			<c path="haxe.ds.ObjectMap">
				<c path="toObjectMap.K"/>
				<c path="Map.V"/>
			</c>
		</to>
		<haxe_doc><![CDATA[Map allows key to value mapping for arbitrary value types, and many key
	types.
		
	This is a multi-type abstract, it is instantiated as one of its
	specialization types depending on its type parameters.
	
	A Map can be instantiated without explicit type parameters. Type inference
	will then determine the type parameters from the usage.
	
	Maps can also be created with [key1 => value1, key2 => value2] syntax.
	
	Map is an abstract type, it is not available at runtime.]]></haxe_doc>
		<meta><m n=":multiType"/></meta>
	</abstract>
	<class path="IMap" params="K:V" file="/usr/lib/haxe/std/Map.hx" module="Map" interface="1">
		<iterator public="1" set="method"><f a=""><t path="Iterator"><c path="IMap.V"/></t></f></iterator>
		<remove public="1" set="method"><f a="k">
	<c path="IMap.K"/>
	<x path="Bool"/>
</f></remove>
		<exists public="1" set="method"><f a="k">
	<c path="IMap.K"/>
	<x path="Bool"/>
</f></exists>
		<set public="1" set="method"><f a="k:v">
	<c path="IMap.K"/>
	<c path="IMap.V"/>
	<x path="Void"/>
</f></set>
		<get public="1" set="method"><f a="k">
	<c path="IMap.K"/>
	<t path="Null"><c path="IMap.V"/></t>
</f></get>
		<meta><m n=":keep"/></meta>
	</class>
	<typedef path="_Map.Hashable" params="" file="/usr/lib/haxe/std/Map.hx" private="1" module="Map"><a><hashCode set="method"><f a=""><x path="Int"/></f></hashCode></a></typedef>
	<class path="Math" params="" file="/usr/lib/haxe/std/Math.hx" extern="1">
		<PI public="1" set="null" static="1"><x path="Float"/></PI>
		<NEGATIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special Float constant which denotes negative infinity.
		
		For example, this is the result of -1.0 / 0.0.
		
		Operations with NEGATIVE_INFINITY as an operand may result in
		Operations with NEGATIVE_INFINITY as an operand may result in
		NEGATIVE_INFINITY, POSITIVE_INFINITY or NaN. For detailed information,
		see ...
		
		If this constant is converted to an Int, e.g. through Std.int(), the
		result is unspecified.</haxe_doc>
		</NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special Float constant which denotes negative infinity.
		
		For example, this is the result of 1.0 / 0.0.
		
		Operations with POSITIVE_INFINITY as an operand may result in
		NEGATIVE_INFINITY, POSITIVE_INFINITY or NaN. For detailed information,
		see ...
	
		If this constant is converted to an Int, e.g. through Std.int(), the
		result is unspecified.</haxe_doc>
		</POSITIVE_INFINITY>
		<NaN public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special Float constant which denotes an invalid number.
		
		NaN stands for "Not a Number". It occurs when a mathematically incorrect
		operation is executed, such as taking the square root of a negative
		number: Math.sqrt(-1).
		
		All further operations with NaN as an operand will result in NaN.
		
		If this constant is converted to an Int, e.g. through Std.int(), the
		result is unspecified.
		
		In order to test if a value is NaN, you should use Math.isNaN() function.
		
		(Php) In PHP versions prior to 5.3.1 VC 9 there may be unexpected
		results when performing arithmetic operations with NaN on Windows, see:
			https://bugs.php.net/bug.php?id=42143</haxe_doc>
		</NaN>
		<abs public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the absolute value of [v].
		
		If [v] is positive or 0, the result is unchanged. Otherwise the result
		is -[v].
		
		If [v] is NEGATIVE_INFINITY or POSITIVE_INFINITY, the result is
		POSITIVE_INFINITY.
		
		If [v] is NaN, the result is NaN.</haxe_doc>
		</abs>
		<min public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the smaller of values [a] and [b].
		
		If [a] or [b] are NaN, the result is NaN.
		
		If [a] or [b] are NEGATIVE_INFINITY, the result is NEGATIVE_INFINITY.
		
		If [a] and [b] are POSITIVE_INFINITY, the result is POSITIVE_INFINITY.</haxe_doc>
		</min>
		<max public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the greater of values [a] and [b].
		
		If [a] or [b] are NaN, the result is NaN.
		
		If [a] or [b] are POSITIVE_INFINITY, the result is POSITIVE_INFINITY.
		
		If [a] and [b] are NEGATIVE_INFINITY, the result is NEGATIVE_INFINITY.</haxe_doc>
		</max>
		<sin public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric sine of [v].
		
		The unit of [v] is radians.
		
		If [v] is NaN or infinite, the result is NaN.</haxe_doc>
		</sin>
		<cos public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric cosine of [v].
		
		The unit of [v] is radians.
		
		If [v] is NaN or infinite, the result is NaN.</haxe_doc>
		</cos>
		<tan public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></tan>
		<asin public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></asin>
		<acos public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></acos>
		<atan public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></atan>
		<atan2 public="1" set="method" static="1"><f a="y:x">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></atan2>
		<exp public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns Euler's number, raised to the power of [v].
		
		exp(1.0) is approximately 2.718281828459.
		
		If [v] is POSITIVE_INFINITY, the result is POSITIVE_INFINITY.
		
		If [v] is NEGATIVE_INFINITY, the result is 0.0.
		
		If [v] is NaN, the result is NaN.</haxe_doc>
		</exp>
		<log public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the natural logarithm of [v].
		
		If [v] is negative (including NEGATIVE_INFINITY) or NaN, the result is
		NaN.
		
		If [v] is POSITIVE_INFINITY, the result is POSITIVE_INFINITY.
		
		If [v] is 0.0, the result is NEGATIVE_INFINITY.
		
		This is the inverse operation of exp, i.e. log(exp(v)) == v always
		holds.</haxe_doc>
		</log>
		<pow public="1" set="method" static="1"><f a="v:exp">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></pow>
		<sqrt public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the square root of [v].
		
		If [v] is negative (including NEGATIVE_INFINITY) or NaN, the result is
		NaN.
		
		If [v] is POSITIVE_INFINITY, the result is POSITIVE_INFINITY.
		
		If [v] is 0.0, the result is 0.0.</haxe_doc>
		</sqrt>
		<round public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Rounds [v] to the nearest Int value.

		If v is outside of the signed Int32 range, or is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, the result is unspecified.
		
		TODO: need spec</haxe_doc>
		</round>
		<floor public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the largest Int value that is not greater than [v].
		
		If v is outside of the signed Int32 range, or is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, the result is unspecified.		
		
		TODO: need spec</haxe_doc>
		</floor>
		<ceil public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the smallest Int value that is not less than [v].

		If v is outside of the signed Int32 range, or is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, the result is unspecified.
		
		TODO: need spec</haxe_doc>
		</ceil>
		<random public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns a pseudo-random number which is greater than or equal to 0.0,
		and less than 1.0.</haxe_doc>
		</random>
		<ffloor public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></ffloor>
		<fceil public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></fceil>
		<fround public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></fround>
		<isFinite public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if [f] is a finite number.
		
		If [f] is POSITIVE_INFINITY, NEGATIVE_INFINITY or NaN, the result is
		false.
		
		Otherwise the result is true.</haxe_doc>
		</isFinite>
		<isNaN public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if [f] is not a valid number.
		
		If [f] is NaN, the result is true.
		
		Otherwise the result is false. In particular, both POSITIVE_INFINITY and
		NEGATIVE_INFINITY are not considered NaN.</haxe_doc>
		</isNaN>
		<haxe_doc>This class defines mathematical functions and constants.</haxe_doc>
	</class>
	<class path="Reflect" params="" file="/usr/lib/haxe/std/flash/_std/Reflect.hx">
		<hasField public="1" set="method" line="24" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if structure [o] has a field named [field].
		
		This is only guaranteed to work for anonymous structures. Refer to
		[Type.getInstanceFields] for a function supporting class instances.
		
		If [o] or [field] are null, the result is unspecified.</haxe_doc>
		</hasField>
		<field public="1" set="method" line="28" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Returns the value of the field named [field] on object [o].
		
		If [o] is not an object or has no field named [field], the result is
		null.
		
		If the field is defined as a property, its accessors are ignored. Refer
		to [Reflect.getProperty] for a function supporting property accessors.
		
		If [field] is null, the result is unspecified.
		
		(As3) If used on a property field, the getter will be invoked. It is
		not possible to obtain the value directly.</haxe_doc>
		</field>
		<fields public="1" set="method" line="59" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the fields of structure [o].
		
		This method is only guaranteed to work on anonymous structures. Refer to
		[Type.getInstanceFields()] for a function supporting class instances.
		
		If [o] is null, the result is unspecified.</haxe_doc>
		</fields>
		<deleteField public="1" set="method" line="114" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the field named [field] from structure [o].
		
		This method is only guaranteed to work on anonymous structures.
		
		If [o] or [field] are null, the result is unspecified.</haxe_doc>
		</deleteField>
		<makeVarArgs public="1" set="method" line="128" static="1">
			<f a="f">
				<f a="">
					<c path="Array"><d/></c>
					<d/>
				</f>
				<d/>
			</f>
			<haxe_doc>Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.</haxe_doc>
		</makeVarArgs>
		<haxe_doc>The Reflect API is a way to manipulate values dynamicly through an
	abstract interface in an untyped manner. Use with care.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="Std" params="" file="/usr/lib/haxe/std/flash/_std/Std.hx">
		<is public="1" set="method" line="26" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if a value v is of the type t. Returns false if v or t are null.</haxe_doc>
		</is>
		<string public="1" set="method" line="30" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Converts any value to a String.

		If s is of String, Int, Float or Bool, its value is returned.

		If s is an instance of a class and that class or one of its parent classes has
		a toString() method, that method is called. If no such method is present, the result
		is unspecified.

		If s is an enum constructor without argument, the constructor's name is returned. If
		arguments exists, the constructor's name followed by the String representations of
		the arguments is returned.

		If s is a structure, the field names along with their values are returned. The field order
		and the operator separating field names and values are unspecified.

		If s is null, "null" is returned.</haxe_doc>
		</string>
		<haxe_doc>The Std class provides standard methods for manipulating basic types.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Void" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<haxe_doc>The standard Void type. Only [null] values can be of the type [Void].</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<abstract path="Float" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<haxe_doc>The standard Float type, this is a double-precision IEEE 64bit float.</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Int" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<to><x path="Float"/></to>
		<haxe_doc>The standard Int type. Its precision depends on the platform.</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="UInt" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<from><x path="Int"/></from>
		<to><x path="Int"/></to>
		<haxe_doc>The unsigned Int type is only defined for Flash9. It's currently
	handled the same as a normal Int.</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Null" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<c path="Null.T"/>
		<haxe_doc>[Null] can be useful in two cases. In order to document some methods
	that accepts or can return a [null] value, or for the Flash9 compiler and AS3
	generator to distinguish between base values that can be null and others that
	can't.</haxe_doc>
	</typedef>
	<abstract path="Bool" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<haxe_doc>The standard Boolean type is represented as an enum with two choices.</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Dynamic" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<haxe_doc>Dynamic is an internal compiler type which has special behavior.
	See the haXe language reference for more informations.</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Iterator" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method">
				<f a=""><c path="Iterator.T"/></f>
				<haxe_doc>Returns the current item of the Iterator and advances to the next one.
		
		This method is not required to check hasNext() first. A call to this
		method while hasNext() is false yields unspecified behavior.</haxe_doc>
			</next>
			<hasNext set="method">
				<f a=""><x path="Bool"/></f>
				<haxe_doc>Returns false if the iteration is complete, true otherwise.
		
		Usually iteration is considered to be complete if all elements of the
		underlying data structure were handled through calls to next(). However,
		in custom iterators any logic may be used to determine the completion
		state.</haxe_doc>
			</hasNext>
		</a>
		<haxe_doc>An Iterator is a structure that permits iteration over elements of type T.

	Any class with matching hasNext and next fields is considered an Iterator
	and can then be used e.g. in for-loops. This makes it easy to implement
	custom iterators.</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>An Iterable is a data structure which has an iterator() method.
	See [Lambda] for generic functions on iterable structures.</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>ArrayAccess is used to indicate a class that can be accessed using brackets.
	The type parameter represent the type of the elements stored.</haxe_doc></class>
	<class path="String" params="" file="/usr/lib/haxe/std/String.hx" extern="1">
		<fromCharCode public="1" set="method" static="1">
			<f a="code">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the String corresponding to the character code [code].
		
		If [code] is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</fromCharCode>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<substring public="1" set="method">
			<f a="startIndex:?endIndex">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the part of [this] String from [startIndex] to [endIndex].
		
		If [startIndex] or [endIndex] are negative, 0 is used instead.
		
		If [startIndex] exceeds [endIndex], they are swapped.
		
		If the (possibly swapped) [endIndex] is omitted or exceeds
		[this].length, [this].length is used instead.
		
		If the (possibly swapped) [startIndex] exceeds [this].length, the empty
		String "" is returned.</haxe_doc>
		</substring>
		<substr public="1" set="method">
			<f a="pos:?len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns [len] characters of [this] String, starting at position [pos].
		
		If [len] is omitted, all characters from position [pos] to the end of
		[this] String are included.
		
		If [pos] is negative, its value is calculated from the end of [this]
		String by [this].length + [pos]. If this yields a negative value, 0 is
		used instead.
		
		If the calculated position + [len] exceeds [this].length, the characters
		from that position to the end of [this] String are returned.
		
		If [len] is negative, the result is unspecified.</haxe_doc>
		</substr>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Splits [this] String at each occurence of [delimiter].
		
		If [delimiter] is the empty String "", [this] String is split into an
		Array of [this].length elements, where the elements correspond to the
		characters of [this] String.
		
		If [delimiter] is not found within [this] String, the result is an Array
		with one element, which equals [this] String.
		
		If [delimiter] is null, the result is unspecified.
		
		Otherwise, [this] String is split into parts at each occurence of
		[delimiter]. If [this] String starts (or ends) with [delimiter}, the
		result Array contains a leading (or trailing) empty String "" element.
		Two subsequent delimiters also result in an empty String "" element.</haxe_doc>
		</split>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the rightmost occurence of [str] within [this]
		String.
		
		If [startIndex] is given, the search is performed within the substring
		of [this] String from 0 to [startIndex]. Otherwise the search is
		performed within [this] String. In either case, the returned position
		is relative to the beginning of [this] String.
		
		If [str] cannot be found, -1 is returned.</haxe_doc>
		</lastIndexOf>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the leftmost occurence of [str] within [this]
		String.
		
		If [startIndex] is given, the search is performed within the substring
		of [this] String starting from [startIndex]. Otherwise the search is
		performed within [this] String. In either case, the returned position
		is relative to the beginning of [this] String.
		
		If [str] cannot be found, -1 is returned.</haxe_doc>
		</indexOf>
		<charCodeAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<t path="Null"><x path="Int"/></t>
			</f>
			<haxe_doc>Returns the character code at position [index] of [this] String.
		
		If [index] is negative or exceeds [this].length, null is returned.
		
		To obtain the character code of a single character, "x".code can be used
		instead to inline the character code at compile time. Note that this
		only works on String literals of length 1.</haxe_doc>
		</charCodeAt>
		<charAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the character at position [index] of [this] String.
		
		If [index] is negative or exceeds [this].length, the empty String ""
		is returned.</haxe_doc>
		</charAt>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of [this] String are lower case.
		
		Affects the characters [A-Z]. Other characters remain unchanged.</haxe_doc>
		</toLowerCase>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of [this] String are upper case.
		
		Affects the characters [a-z]. Other characters remain unchanged.</haxe_doc>
		</toUpperCase>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The number of characters in [this] String.</haxe_doc>
		</length>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a copy from a given String.</haxe_doc>
		</new>
		<haxe_doc>The basic String class.
	
	A haxe String is immutable, it is not possible to modify individual
	characters. No method of this class changes the state of [this] String.
	
	Strings can be constructed using the string literal syntax "string value".
	
	String can be concatenated by using the + operator. If an operand is not a
	String, it is passed through Std.string() first.</haxe_doc>
	</class>
	<enum path="ValueType" params="" file="/usr/lib/haxe/std/flash/_std/Type.hx" module="Type">
		<TUnknown/>
		<TObject/>
		<TNull/>
		<TInt/>
		<TFunction/>
		<TFloat/>
		<TEnum a="e"><x path="Enum"><d/></x></TEnum>
		<TClass a="c"><x path="Class"><d/></x></TClass>
		<TBool/>
	</enum>
	<class path="Type" params="" file="/usr/lib/haxe/std/flash/_std/Type.hx">
		<getClass public="1" params="T" set="method" line="36" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<x path="Class"><c path="getClass.T"/></x>
			</f>
			<haxe_doc>Returns the class of [o], if [o] is a class instance.
		
		If [o] is null or of a different type, null is returned.
		
		In general, type parameter information cannot be obtained at runtime.</haxe_doc>
		</getClass>
		<getSuperClass public="1" set="method" line="62" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<x path="Class"><d/></x>
			</f>
			<haxe_doc>Returns the super-class of class [c].
		
		If [c] has no super class, null is returned.
		
		If [c] is null, the result is unspecified.
		
		In general, type parameter information cannot be obtained at runtime.</haxe_doc>
		</getSuperClass>
		<getClassName public="1" set="method" line="69" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of class [c], including its path.
		
		If [c] is inside a package, the package structure is returned dot-
		separated, with another dot separating the class name:
			pack1.pack2.(...).packN.ClassName
		If [c] is a sub-type of a haxe module, that module is not part of the
		package structure.
			
		If [c] has no package, the class name is returned.
		
		If [c] is null, the result is unspecified.
		
		The class name does not include any type parameters.</haxe_doc>
		</getClassName>
		<resolveClass public="1" set="method" line="89" static="1">
			<f a="name">
				<c path="String"/>
				<x path="Class"><d/></x>
			</f>
			<haxe_doc>Resolves a class by name.
		
		If [name] is the path of an existing class, that class is returned.
		
		Otherwise null is returned.
		
		If [name] is null or the path to a different type, the result is
		unspecified.
		
		The class name must not include any type parameters.</haxe_doc>
		</resolveClass>
		<createInstance public="1" params="T" set="method" line="130" static="1">
			<f a="cl:args">
				<x path="Class"><c path="createInstance.T"/></x>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<haxe_doc>Creates an instance of class [cl], using [args] as arguments to the
		class constructor.
		
		This function guarantees that the class constructor is called.
		
		Default values of constructors arguments are not guaranteed to be
		taken into account.
		
		If [cl] or [args] are null, or if the number of elements in [args] does
		not match the expected number of constructor arguments, or if any
		argument has an invalid type,  or if [cl] has no own constructor, the
		result is unspecified.
		
		In particular, default values of constructor arguments are not
		guaranteed to be taken into account.</haxe_doc>
		</createInstance>
		<createEmptyInstance public="1" params="T" set="method" line="151" static="1">
			<f a="cl">
				<x path="Class"><c path="createEmptyInstance.T"/></x>
				<c path="createEmptyInstance.T"/>
			</f>
			<haxe_doc>Creates an instance of class [cl].
		
		This function guarantees that the class constructor is not called.
		
		If [cl] is null, the result is unspecified.</haxe_doc>
		</createEmptyInstance>
		<typeof public="1" set="method" line="215" static="1">
			<f a="v">
				<d/>
				<e path="ValueType"/>
			</f>
			<haxe_doc>Returns the runtime type of value [v].
		
		The result corresponds to the type [v] has at runtime, which may vary
		per platform. Assumptions regarding this should be minimized to avoid
		surprises.</haxe_doc>
		</typeof>
		<haxe_doc>The haxe Reflection API allows retrieval of type information at runtime.
	
	This class complements the more lightweight Reflect class, with a focus on
	class and enum instances.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="flash.events.IEventDispatcher" params="" file="/usr/lib/haxe/std/flash/events/IEventDispatcher.hx" extern="1" interface="1">
		<willTrigger public="1" set="method"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></willTrigger>
		<removeEventListener public="1" set="method"><f a="type:listener:?useCapture">
	<c path="String"/>
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<x path="Bool"/>
	<x path="Void"/>
</f></removeEventListener>
		<hasEventListener public="1" set="method"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></hasEventListener>
		<dispatchEvent public="1" set="method"><f a="event">
	<c path="flash.events.Event"/>
	<x path="Bool"/>
</f></dispatchEvent>
		<addEventListener public="1" set="method"><f a="type:listener:?useCapture:?priority:?useWeakReference">
	<c path="String"/>
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></addEventListener>
	</class>
	<class path="flash.events.EventDispatcher" params="" file="/usr/lib/haxe/std/flash/events/EventDispatcher.hx" extern="1">
		<implements path="flash.events.IEventDispatcher"/>
		<willTrigger public="1" set="method"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></willTrigger>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<removeEventListener public="1" set="method"><f a="type:listener:?useCapture">
	<c path="String"/>
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<x path="Bool"/>
	<x path="Void"/>
</f></removeEventListener>
		<hasEventListener public="1" set="method"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></hasEventListener>
		<dispatchEvent public="1" set="method"><f a="event">
	<c path="flash.events.Event"/>
	<x path="Bool"/>
</f></dispatchEvent>
		<addEventListener public="1" set="method"><f a="type:listener:?useCapture:?priority:?useWeakReference">
	<c path="String"/>
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></addEventListener>
		<new public="1" set="method"><f a="?target">
	<c path="flash.events.IEventDispatcher"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.display.IBitmapDrawable" params="" file="/usr/lib/haxe/std/flash/display/IBitmapDrawable.hx" extern="1" interface="1"/>
	<class path="flash.display.DisplayObject" params="" file="/usr/lib/haxe/std/flash/display/DisplayObject.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<implements path="flash.display.IBitmapDrawable"/>
		<localToGlobal public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></localToGlobal>
		<local3DToGlobal public="1" set="method">
			<f a="point3d">
				<c path="flash.geom.Vector3D"/>
				<c path="flash.geom.Point"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</local3DToGlobal>
		<hitTestPoint public="1" set="method"><f a="x:y:?shapeFlag">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></hitTestPoint>
		<hitTestObject public="1" set="method"><f a="obj">
	<c path="flash.display.DisplayObject"/>
	<x path="Bool"/>
</f></hitTestObject>
		<globalToLocal3D public="1" set="method">
			<f a="point">
				<c path="flash.geom.Point"/>
				<c path="flash.geom.Vector3D"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</globalToLocal3D>
		<globalToLocal public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></globalToLocal>
		<getRect public="1" set="method"><f a="targetCoordinateSpace">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.geom.Rectangle"/>
</f></getRect>
		<getBounds public="1" set="method"><f a="targetCoordinateSpace">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.geom.Rectangle"/>
</f></getBounds>
		<z public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</z>
		<y public="1"><x path="Float"/></y>
		<x public="1"><x path="Float"/></x>
		<width public="1"><x path="Float"/></width>
		<visible public="1"><x path="Bool"/></visible>
		<transform public="1"><c path="flash.geom.Transform"/></transform>
		<stage public="1" set="null"><c path="flash.display.Stage"/></stage>
		<scrollRect public="1"><c path="flash.geom.Rectangle"/></scrollRect>
		<scaleZ public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</scaleZ>
		<scaleY public="1"><x path="Float"/></scaleY>
		<scaleX public="1"><x path="Float"/></scaleX>
		<scale9Grid public="1"><c path="flash.geom.Rectangle"/></scale9Grid>
		<rotationZ public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</rotationZ>
		<rotationY public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</rotationY>
		<rotationX public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</rotationX>
		<rotation public="1"><x path="Float"/></rotation>
		<root public="1" set="null"><c path="flash.display.DisplayObject"/></root>
		<parent public="1" set="null"><c path="flash.display.DisplayObjectContainer"/></parent>
		<opaqueBackground public="1"><t path="Null"><x path="UInt"/></t></opaqueBackground>
		<name public="1"><c path="String"/></name>
		<mouseY public="1" set="null"><x path="Float"/></mouseY>
		<mouseX public="1" set="null"><x path="Float"/></mouseX>
		<mask public="1"><c path="flash.display.DisplayObject"/></mask>
		<loaderInfo public="1" set="null"><c path="flash.display.LoaderInfo"/></loaderInfo>
		<height public="1"><x path="Float"/></height>
		<filters public="1"><c path="Array"><c path="flash.filters.BitmapFilter"/></c></filters>
		<cacheAsBitmap public="1"><x path="Bool"/></cacheAsBitmap>
		<blendShader public="1" get="null">
			<c path="flash.display.Shader"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</blendShader>
		<blendMode public="1"><e path="flash.display.BlendMode"/></blendMode>
		<alpha public="1"><x path="Float"/></alpha>
		<accessibilityProperties public="1"><c path="flash.accessibility.AccessibilityProperties"/></accessibilityProperties>
	</class>
	<class path="flash.display.InteractiveObject" params="" file="/usr/lib/haxe/std/flash/display/InteractiveObject.hx" extern="1">
		<extends path="flash.display.DisplayObject"/>
		<requestSoftKeyboard public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</requestSoftKeyboard>
		<tabIndex public="1"><x path="Int"/></tabIndex>
		<tabEnabled public="1"><x path="Bool"/></tabEnabled>
		<softKeyboardInputAreaOfInterest public="1">
			<c path="flash.geom.Rectangle"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</softKeyboardInputAreaOfInterest>
		<needsSoftKeyboard public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</needsSoftKeyboard>
		<mouseEnabled public="1"><x path="Bool"/></mouseEnabled>
		<focusRect public="1"><d/></focusRect>
		<doubleClickEnabled public="1"><x path="Bool"/></doubleClickEnabled>
		<contextMenu public="1"><c path="flash.ui.ContextMenu"/></contextMenu>
		<accessibilityImplementation public="1"><c path="flash.accessibility.AccessibilityImplementation"/></accessibilityImplementation>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.display.DisplayObjectContainer" params="" file="/usr/lib/haxe/std/flash/display/DisplayObjectContainer.hx" extern="1">
		<extends path="flash.display.InteractiveObject"/>
		<swapChildrenAt public="1" set="method"><f a="index1:index2">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></swapChildrenAt>
		<swapChildren public="1" set="method"><f a="child1:child2">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
	<x path="Void"/>
</f></swapChildren>
		<setChildIndex public="1" set="method"><f a="child:index">
	<c path="flash.display.DisplayObject"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setChildIndex>
		<removeChildren public="1" set="method">
			<f a="?beginIndex:?endIndex">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</removeChildren>
		<removeChildAt public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></removeChildAt>
		<removeChild public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
</f></removeChild>
		<getObjectsUnderPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="Array"><c path="flash.display.DisplayObject"/></c>
</f></getObjectsUnderPoint>
		<getChildIndex public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<x path="Int"/>
</f></getChildIndex>
		<getChildByName public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="flash.display.DisplayObject"/>
</f></getChildByName>
		<getChildAt public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></getChildAt>
		<contains public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<x path="Bool"/>
</f></contains>
		<areInaccessibleObjectsUnderPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<x path="Bool"/>
</f></areInaccessibleObjectsUnderPoint>
		<addChildAt public="1" set="method"><f a="child:index">
	<c path="flash.display.DisplayObject"/>
	<x path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></addChildAt>
		<addChild public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
</f></addChild>
		<textSnapshot public="1" set="null"><c path="flash.text.TextSnapshot"/></textSnapshot>
		<tabChildren public="1"><x path="Bool"/></tabChildren>
		<numChildren public="1" set="null"><x path="Int"/></numChildren>
		<mouseChildren public="1"><x path="Bool"/></mouseChildren>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.display.Sprite" params="" file="/usr/lib/haxe/std/flash/display/Sprite.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<stopTouchDrag public="1" set="method">
			<f a="touchPointID">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</stopTouchDrag>
		<stopDrag public="1" set="method"><f a=""><x path="Void"/></f></stopDrag>
		<startTouchDrag public="1" set="method">
			<f a="touchPointID:?lockCenter:?bounds">
				<x path="Int"/>
				<x path="Bool"/>
				<c path="flash.geom.Rectangle"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</startTouchDrag>
		<startDrag public="1" set="method"><f a="?lockCenter:?bounds">
	<x path="Bool"/>
	<c path="flash.geom.Rectangle"/>
	<x path="Void"/>
</f></startDrag>
		<useHandCursor public="1"><x path="Bool"/></useHandCursor>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<hitArea public="1"><c path="flash.display.Sprite"/></hitArea>
		<graphics public="1" set="null"><c path="flash.display.Graphics"/></graphics>
		<dropTarget public="1" set="null"><c path="flash.display.DisplayObject"/></dropTarget>
		<buttonMode public="1"><x path="Bool"/></buttonMode>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.display.MovieClip" params="" file="/usr/lib/haxe/std/flash/display/MovieClip.hx" extern="1">
		<extends path="flash.display.Sprite"/>
		<stop public="1" set="method"><f a=""><x path="Void"/></f></stop>
		<prevScene public="1" set="method"><f a=""><x path="Void"/></f></prevScene>
		<prevFrame public="1" set="method"><f a=""><x path="Void"/></f></prevFrame>
		<play public="1" set="method"><f a=""><x path="Void"/></f></play>
		<nextScene public="1" set="method"><f a=""><x path="Void"/></f></nextScene>
		<nextFrame public="1" set="method"><f a=""><x path="Void"/></f></nextFrame>
		<gotoAndStop public="1" set="method"><f a="frame:?scene">
	<t path="flash.utils.Object"/>
	<c path="String"/>
	<x path="Void"/>
</f></gotoAndStop>
		<gotoAndPlay public="1" set="method"><f a="frame:?scene">
	<t path="flash.utils.Object"/>
	<c path="String"/>
	<x path="Void"/>
</f></gotoAndPlay>
		<addFrameScript public="1" set="method"><f a="?p1:?p2:?p3:?p4:?p5">
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<x path="Void"/>
</f></addFrameScript>
		<trackAsMenu public="1"><x path="Bool"/></trackAsMenu>
		<totalFrames public="1" set="null"><x path="Int"/></totalFrames>
		<scenes public="1" set="null"><c path="Array"><c path="flash.display.Scene"/></c></scenes>
		<isPlaying public="1" set="null">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</isPlaying>
		<framesLoaded public="1" set="null"><x path="Int"/></framesLoaded>
		<enabled public="1"><x path="Bool"/></enabled>
		<currentScene public="1" set="null"><c path="flash.display.Scene"/></currentScene>
		<currentLabels public="1" set="null"><c path="Array"><c path="flash.display.FrameLabel"/></c></currentLabels>
		<currentLabel public="1" set="null"><c path="String"/></currentLabel>
		<currentFrameLabel public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</currentFrameLabel>
		<currentFrame public="1" set="null"><x path="Int"/></currentFrame>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.Boot" params="" file="/usr/lib/haxe/std/flash/Boot.hx">
		<extends path="flash.display.MovieClip"/>
		<tf static="1"><c path="flash.text.TextField"/></tf>
		<lines static="1"><c path="Array"><c path="String"/></c></lines>
		<lastError static="1"><c path="flash.errors.Error"/></lastError>
		<skip_constructor public="1" line="51" static="1"><x path="Bool"/></skip_constructor>
		<enum_to_string public="1" set="method" line="83" static="1"><f a="e">
	<a>
		<tag><c path="String"/></tag>
		<params><c path="Array"><d/></c></params>
	</a>
	<c path="String"/>
</f></enum_to_string>
		<__instanceof public="1" set="method" line="92" static="1"><f a="v:t">
	<d/>
	<d/>
	<x path="Bool"/>
</f></__instanceof>
		<__clear_trace public="1" set="method" line="102" static="1"><f a=""><x path="Void"/></f></__clear_trace>
		<__set_trace_color public="1" set="method" line="110" static="1"><f a="rgb">
	<x path="UInt"/>
	<x path="Void"/>
</f></__set_trace_color>
		<getTrace public="1" set="method" line="116" static="1"><f a=""><c path="flash.text.TextField"/></f></getTrace>
		<__trace public="1" set="method" line="144" static="1"><f a="v:pos">
	<d/>
	<t path="haxe.PosInfos"/>
	<x path="Void"/>
</f></__trace>
		<__string_rec public="1" set="method" line="163" static="1"><f a="v:str">
	<d/>
	<c path="String"/>
	<c path="String"/>
</f></__string_rec>
		<__unprotect__ set="method" line="208" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></__unprotect__>
		<init set="method" line="79"><f a=""><x path="Void"/></f></init>
		<doInitDelay set="method" line="74"><f a="_">
	<unknown/>
	<x path="Void"/>
</f></doInitDelay>
		<start set="method" line="53"><f a=""><x path="Void"/></f></start>
		<new public="1" set="method" line="45"><f a=""><x path="Void"/></f></new>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="flash._Boot.RealBoot" params="" file="/usr/lib/haxe/std/flash/Boot.hx" private="1" module="flash.Boot">
		<extends path="flash.Boot"/>
		<new set="method" line="35"><f a=""><x path="Void"/></f></new>
		<meta><m n=":keep"/></meta>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.Lib" params="" file="/usr/lib/haxe/std/flash/Lib.hx">
		<current public="1" static="1"><c path="flash.display.MovieClip"/></current>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="flash.Vector" params="T" file="/usr/lib/haxe/std/flash/Vector.hx" extern="1">
		<ofArray public="1" params="T" get="inline" set="null" line="47" static="1"><f a="v">
	<c path="Array"><c path="ofArray.T"/></c>
	<c path="flash.Vector"><c path="ofArray.T"/></c>
</f></ofArray>
		<convert public="1" params="T:U" get="inline" set="null" line="51" static="1"><f a="v">
	<c path="flash.Vector"><c path="convert.T"/></c>
	<c path="flash.Vector"><c path="convert.U"/></c>
</f></convert>
		<lastIndexOf public="1" set="method"><f a="x:?from">
	<c path="flash.Vector.T"/>
	<x path="Int"/>
	<x path="Int"/>
</f></lastIndexOf>
		<indexOf public="1" set="method"><f a="x:?from">
	<c path="flash.Vector.T"/>
	<x path="Int"/>
	<x path="Int"/>
</f></indexOf>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<splice public="1" set="method"><f a="pos:len">
	<x path="Int"/>
	<x path="Int"/>
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
</f></splice>
		<sort public="1" set="method"><f a="f">
	<f a=":">
		<c path="flash.Vector.T"/>
		<c path="flash.Vector.T"/>
		<x path="Int"/>
	</f>
	<x path="Void"/>
</f></sort>
		<slice public="1" set="method"><f a="?pos:?end">
	<x path="Int"/>
	<x path="Int"/>
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
</f></slice>
		<unshift public="1" set="method"><f a="x">
	<c path="flash.Vector.T"/>
	<x path="Void"/>
</f></unshift>
		<shift public="1" set="method"><f a=""><t path="Null"><c path="flash.Vector.T"/></t></f></shift>
		<reverse public="1" set="method"><f a=""><x path="Void"/></f></reverse>
		<push public="1" set="method"><f a="x">
	<c path="flash.Vector.T"/>
	<x path="Int"/>
</f></push>
		<pop public="1" set="method"><f a=""><t path="Null"><c path="flash.Vector.T"/></t></f></pop>
		<join public="1" set="method"><f a="sep">
	<c path="String"/>
	<c path="String"/>
</f></join>
		<concat public="1" set="method"><f a="?a">
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
</f></concat>
		<fixed public="1"><x path="Bool"/></fixed>
		<length public="1"><x path="Int"/></length>
		<new public="1" set="method"><f a="?length:?fixed">
	<x path="UInt"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>The Vector class is very similar to Array but is only supported by the Flash Player 10+</haxe_doc>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.accessibility.AccessibilityImplementation" params="" file="/usr/lib/haxe/std/flash/accessibility/AccessibilityImplementation.hx" extern="1">
		<isLabeledBy public="1" set="method"><f a="labelBounds">
	<c path="flash.geom.Rectangle"/>
	<x path="Bool"/>
</f></isLabeledBy>
		<get_selectionAnchorIndex public="1" set="method"><f a=""><d/></f></get_selectionAnchorIndex>
		<get_selectionActiveIndex public="1" set="method"><f a=""><d/></f></get_selectionActiveIndex>
		<get_accValue public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<c path="String"/>
</f></get_accValue>
		<get_accState public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<x path="UInt"/>
</f></get_accState>
		<get_accSelection public="1" set="method"><f a=""><c path="Array"><d/></c></f></get_accSelection>
		<get_accRole public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<x path="UInt"/>
</f></get_accRole>
		<get_accName public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<c path="String"/>
</f></get_accName>
		<get_accFocus public="1" set="method"><f a=""><x path="UInt"/></f></get_accFocus>
		<get_accDefaultAction public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<c path="String"/>
</f></get_accDefaultAction>
		<getChildIDArray public="1" set="method"><f a=""><c path="Array"><d/></c></f></getChildIDArray>
		<accSelect public="1" set="method"><f a="operation:childID">
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></accSelect>
		<accLocation public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<d/>
</f></accLocation>
		<accDoDefaultAction public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<x path="Void"/>
</f></accDoDefaultAction>
		<stub public="1"><x path="Bool"/></stub>
		<errno public="1"><x path="UInt"/></errno>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.accessibility.AccessibilityProperties" params="" file="/usr/lib/haxe/std/flash/accessibility/AccessibilityProperties.hx" extern="1">
		<silent public="1"><x path="Bool"/></silent>
		<shortcut public="1"><c path="String"/></shortcut>
		<noAutoLabeling public="1"><x path="Bool"/></noAutoLabeling>
		<name public="1"><c path="String"/></name>
		<forceSimple public="1"><x path="Bool"/></forceSimple>
		<description public="1"><c path="String"/></description>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<enum path="flash.display.ActionScriptVersion" params="" file="/usr/lib/haxe/std/flash/display/ActionScriptVersion.hx">
		<ACTIONSCRIPT3/>
		<ACTIONSCRIPT2/>
		<meta><m n=":fakeEnum"><e>UInt</e></m></meta>
	</enum>
	<class path="flash.display.BitmapData" params="" file="/usr/lib/haxe/std/flash/display/BitmapData.hx" extern="1">
		<implements path="flash.display.IBitmapDrawable"/>
		<unlock public="1" set="method"><f a="?changeRect">
	<c path="flash.geom.Rectangle"/>
	<x path="Void"/>
</f></unlock>
		<threshold public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:operation:threshold:?color:?mask:?copySource">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="String"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Bool"/>
	<x path="UInt"/>
</f></threshold>
		<setVector public="1" set="method">
			<f a="rect:inputVector">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.Vector"><x path="UInt"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</setVector>
		<setPixels public="1" set="method"><f a="rect:inputByteArray">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.utils.ByteArray"/>
	<x path="Void"/>
</f></setPixels>
		<setPixel32 public="1" set="method"><f a="x:y:color">
	<x path="Int"/>
	<x path="Int"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></setPixel32>
		<setPixel public="1" set="method"><f a="x:y:color">
	<x path="Int"/>
	<x path="Int"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></setPixel>
		<scroll public="1" set="method"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></scroll>
		<pixelDissolve public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:?randomSeed:?numPixels:?fillColor">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="UInt"/>
	<x path="Int"/>
</f></pixelDissolve>
		<perlinNoise public="1" set="method"><f a="baseX:baseY:numOctaves:randomSeed:stitch:fractalNoise:?channelOptions:?grayScale:?offsets">
	<x path="Float"/>
	<x path="Float"/>
	<x path="UInt"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="UInt"/>
	<x path="Bool"/>
	<c path="Array"><c path="flash.geom.Point"/></c>
	<x path="Void"/>
</f></perlinNoise>
		<paletteMap public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:?redArray:?greenArray:?blueArray:?alphaArray">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></paletteMap>
		<noise public="1" set="method"><f a="randomSeed:?low:?high:?channelOptions:?grayScale">
	<x path="Int"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></noise>
		<merge public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:redMultiplier:greenMultiplier:blueMultiplier:alphaMultiplier">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></merge>
		<lock public="1" set="method"><f a=""><x path="Void"/></f></lock>
		<hitTest public="1" set="method"><f a="firstPoint:firstAlphaThreshold:secondObject:?secondBitmapDataPoint:?secondAlphaThreshold">
	<c path="flash.geom.Point"/>
	<x path="UInt"/>
	<t path="flash.utils.Object"/>
	<c path="flash.geom.Point"/>
	<x path="UInt"/>
	<x path="Bool"/>
</f></hitTest>
		<histogram public="1" set="method">
			<f a="?hRect">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.Vector"><c path="flash.Vector"><x path="Float"/></c></c>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</histogram>
		<getVector public="1" set="method">
			<f a="rect">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.Vector"><x path="UInt"/></c>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</getVector>
		<getPixels public="1" set="method"><f a="rect">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.utils.ByteArray"/>
</f></getPixels>
		<getPixel32 public="1" set="method"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="UInt"/>
</f></getPixel32>
		<getPixel public="1" set="method"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="UInt"/>
</f></getPixel>
		<getColorBoundsRect public="1" set="method"><f a="mask:color:?findColor">
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Bool"/>
	<c path="flash.geom.Rectangle"/>
</f></getColorBoundsRect>
		<generateFilterRect public="1" set="method"><f a="sourceRect:filter">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.filters.BitmapFilter"/>
	<c path="flash.geom.Rectangle"/>
</f></generateFilterRect>
		<floodFill public="1" set="method"><f a="x:y:color">
	<x path="Int"/>
	<x path="Int"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></floodFill>
		<fillRect public="1" set="method"><f a="rect:color">
	<c path="flash.geom.Rectangle"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></fillRect>
		<draw public="1" set="method"><f a="source:?matrix:?colorTransform:?blendMode:?clipRect:?smoothing">
	<c path="flash.display.IBitmapDrawable"/>
	<c path="flash.geom.Matrix"/>
	<c path="flash.geom.ColorTransform"/>
	<e path="flash.display.BlendMode"/>
	<c path="flash.geom.Rectangle"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></draw>
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<copyPixels public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:?alphaBitmapData:?alphaPoint:?mergeAlpha">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Point"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></copyPixels>
		<copyChannel public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:sourceChannel:destChannel">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></copyChannel>
		<compare public="1" set="method"><f a="otherBitmapData">
	<c path="flash.display.BitmapData"/>
	<t path="flash.utils.Object"/>
</f></compare>
		<colorTransform public="1" set="method"><f a="rect:colorTransform">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.ColorTransform"/>
	<x path="Void"/>
</f></colorTransform>
		<clone public="1" set="method"><f a=""><c path="flash.display.BitmapData"/></f></clone>
		<applyFilter public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:filter">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="flash.filters.BitmapFilter"/>
	<x path="Void"/>
</f></applyFilter>
		<width public="1" set="null"><x path="Int"/></width>
		<transparent public="1" set="null"><x path="Bool"/></transparent>
		<rect public="1" set="null"><c path="flash.geom.Rectangle"/></rect>
		<height public="1" set="null"><x path="Int"/></height>
		<new public="1" set="method"><f a="width:height:?transparent:?fillColor">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="flash.display.BlendMode" params="" file="/usr/lib/haxe/std/flash/display/BlendMode.hx">
		<SUBTRACT/>
		<SHADER/>
		<SCREEN/>
		<OVERLAY/>
		<NORMAL/>
		<MULTIPLY/>
		<LIGHTEN/>
		<LAYER/>
		<INVERT/>
		<HARDLIGHT/>
		<ERASE/>
		<DIFFERENCE/>
		<DARKEN/>
		<ALPHA/>
		<ADD/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.CapsStyle" params="" file="/usr/lib/haxe/std/flash/display/CapsStyle.hx">
		<SQUARE/>
		<ROUND/>
		<NONE/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.ColorCorrection" params="" file="/usr/lib/haxe/std/flash/display/ColorCorrection.hx">
		<ON/>
		<OFF/>
		<DEFAULT/>
		<meta>
			<m n=":fakeEnum"><e>String</e></m>
			<m n=":require"><e>flash10_1</e></m>
		</meta>
	</enum>
	<enum path="flash.display.ColorCorrectionSupport" params="" file="/usr/lib/haxe/std/flash/display/ColorCorrectionSupport.hx">
		<UNSUPPORTED/>
		<DEFAULT_ON/>
		<DEFAULT_OFF/>
		<meta>
			<m n=":fakeEnum"><e>String</e></m>
			<m n=":require"><e>flash10_1</e></m>
		</meta>
	</enum>
	<class path="flash.display.FrameLabel" params="" file="/usr/lib/haxe/std/flash/display/FrameLabel.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<name public="1" set="null"><c path="String"/></name>
		<frame public="1" set="null"><x path="Int"/></frame>
		<new public="1" set="method"><f a="name:frame">
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.display.GradientType" params="" file="/usr/lib/haxe/std/flash/display/GradientType.hx">
		<RADIAL/>
		<LINEAR/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display.Graphics" params="" file="/usr/lib/haxe/std/flash/display/Graphics.hx" extern="1">
		<moveTo public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></moveTo>
		<lineTo public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineTo>
		<lineStyle public="1" set="method"><f a="?thickness:?color:?alpha:?pixelHinting:?scaleMode:?caps:?joints:?miterLimit">
	<x path="Float"/>
	<x path="UInt"/>
	<x path="Float"/>
	<x path="Bool"/>
	<e path="flash.display.LineScaleMode"/>
	<e path="flash.display.CapsStyle"/>
	<e path="flash.display.JointStyle"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineStyle>
		<lineShaderStyle public="1" set="method">
			<f a="shader:?matrix">
				<c path="flash.display.Shader"/>
				<c path="flash.geom.Matrix"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</lineShaderStyle>
		<lineGradientStyle public="1" set="method"><f a="type:colors:alphas:ratios:?matrix:?spreadMethod:?interpolationMethod:?focalPointRatio">
	<e path="flash.display.GradientType"/>
	<c path="Array"><x path="UInt"/></c>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<c path="flash.geom.Matrix"/>
	<e path="flash.display.SpreadMethod"/>
	<e path="flash.display.InterpolationMethod"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineGradientStyle>
		<lineBitmapStyle public="1" set="method">
			<f a="bitmap:?matrix:?repeat:?smooth">
				<c path="flash.display.BitmapData"/>
				<c path="flash.geom.Matrix"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</lineBitmapStyle>
		<endFill public="1" set="method"><f a=""><x path="Void"/></f></endFill>
		<drawTriangles public="1" set="method">
			<f a="vertices:?indices:?uvtData:?culling">
				<c path="flash.Vector"><x path="Float"/></c>
				<c path="flash.Vector"><x path="Int"/></c>
				<c path="flash.Vector"><x path="Float"/></c>
				<e path="flash.display.TriangleCulling"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</drawTriangles>
		<drawRoundRectComplex public="1" set="method"><f a="x:y:width:height:topLeftRadius:topRightRadius:bottomLeftRadius:bottomRightRadius">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawRoundRectComplex>
		<drawRoundRect public="1" set="method"><f a="x:y:width:height:ellipseWidth:?ellipseHeight">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawRoundRect>
		<drawRect public="1" set="method"><f a="x:y:width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawRect>
		<drawPath public="1" set="method">
			<f a="commands:data:?winding">
				<c path="flash.Vector"><x path="Int"/></c>
				<c path="flash.Vector"><x path="Float"/></c>
				<e path="flash.display.GraphicsPathWinding"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</drawPath>
		<drawGraphicsData public="1" set="method">
			<f a="graphicsData">
				<c path="flash.Vector"><c path="flash.display.IGraphicsData"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</drawGraphicsData>
		<drawEllipse public="1" set="method"><f a="x:y:width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawEllipse>
		<drawCircle public="1" set="method"><f a="x:y:radius">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawCircle>
		<curveTo public="1" set="method"><f a="controlX:controlY:anchorX:anchorY">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></curveTo>
		<cubicCurveTo public="1" set="method">
			<f a="controlX1:controlY1:controlX2:controlY2:anchorX:anchorY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</cubicCurveTo>
		<copyFrom public="1" set="method">
			<f a="sourceGraphics">
				<c path="flash.display.Graphics"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</copyFrom>
		<clear public="1" set="method"><f a=""><x path="Void"/></f></clear>
		<beginShaderFill public="1" set="method">
			<f a="shader:?matrix">
				<c path="flash.display.Shader"/>
				<c path="flash.geom.Matrix"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</beginShaderFill>
		<beginGradientFill public="1" set="method"><f a="type:colors:alphas:ratios:?matrix:?spreadMethod:?interpolationMethod:?focalPointRatio">
	<e path="flash.display.GradientType"/>
	<c path="Array"><x path="UInt"/></c>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<c path="flash.geom.Matrix"/>
	<e path="flash.display.SpreadMethod"/>
	<e path="flash.display.InterpolationMethod"/>
	<x path="Float"/>
	<x path="Void"/>
</f></beginGradientFill>
		<beginFill public="1" set="method"><f a="color:?alpha">
	<x path="UInt"/>
	<x path="Float"/>
	<x path="Void"/>
</f></beginFill>
		<beginBitmapFill public="1" set="method"><f a="bitmap:?matrix:?repeat:?smooth">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Matrix"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></beginBitmapFill>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.display.GraphicsPathWinding" params="" file="/usr/lib/haxe/std/flash/display/GraphicsPathWinding.hx">
		<NON_ZERO/>
		<EVEN_ODD/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display.IGraphicsData" params="" file="/usr/lib/haxe/std/flash/display/IGraphicsData.hx" extern="1" interface="1"/>
	<enum path="flash.display.InterpolationMethod" params="" file="/usr/lib/haxe/std/flash/display/InterpolationMethod.hx">
		<RGB/>
		<LINEAR_RGB/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.JointStyle" params="" file="/usr/lib/haxe/std/flash/display/JointStyle.hx">
		<ROUND/>
		<MITER/>
		<BEVEL/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.LineScaleMode" params="" file="/usr/lib/haxe/std/flash/display/LineScaleMode.hx">
		<VERTICAL/>
		<NORMAL/>
		<NONE/>
		<HORIZONTAL/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display.Loader" params="" file="/usr/lib/haxe/std/flash/display/Loader.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<unloadAndStop public="1" set="method">
			<f a="?gc">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</unloadAndStop>
		<unload public="1" set="method"><f a=""><x path="Void"/></f></unload>
		<loadBytes public="1" set="method"><f a="bytes:?context">
	<c path="flash.utils.ByteArray"/>
	<c path="flash.system.LoaderContext"/>
	<x path="Void"/>
</f></loadBytes>
		<load public="1" set="method"><f a="request:?context">
	<c path="flash.net.URLRequest"/>
	<c path="flash.system.LoaderContext"/>
	<x path="Void"/>
</f></load>
		<close public="1" set="method"><f a=""><x path="Void"/></f></close>
		<uncaughtErrorEvents public="1" set="null">
			<c path="flash.events.UncaughtErrorEvents"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</uncaughtErrorEvents>
		<contentLoaderInfo public="1" set="null"><c path="flash.display.LoaderInfo"/></contentLoaderInfo>
		<content public="1" set="null"><c path="flash.display.DisplayObject"/></content>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.display.LoaderInfo" params="" file="/usr/lib/haxe/std/flash/display/LoaderInfo.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<getLoaderInfoByDefinition public="1" set="method" static="1"><f a="object">
	<d/>
	<c path="flash.display.LoaderInfo"/>
</f></getLoaderInfoByDefinition>
		<width public="1" set="null"><x path="Int"/></width>
		<url public="1" set="null"><c path="String"/></url>
		<uncaughtErrorEvents public="1" set="null">
			<c path="flash.events.UncaughtErrorEvents"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</uncaughtErrorEvents>
		<swfVersion public="1" set="null"><x path="UInt"/></swfVersion>
		<sharedEvents public="1" set="null"><c path="flash.events.EventDispatcher"/></sharedEvents>
		<sameDomain public="1" set="null"><x path="Bool"/></sameDomain>
		<parentAllowsChild public="1" set="null"><x path="Bool"/></parentAllowsChild>
		<parameters public="1" set="null"><d><c path="String"/></d></parameters>
		<loaderURL public="1" set="null"><c path="String"/></loaderURL>
		<loader public="1" set="null"><c path="flash.display.Loader"/></loader>
		<isURLInaccessible public="1" set="null">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</isURLInaccessible>
		<height public="1" set="null"><x path="Int"/></height>
		<frameRate public="1" set="null"><x path="Float"/></frameRate>
		<contentType public="1" set="null"><c path="String"/></contentType>
		<content public="1" set="null"><c path="flash.display.DisplayObject"/></content>
		<childAllowsParent public="1" set="null"><x path="Bool"/></childAllowsParent>
		<bytesTotal public="1" set="null"><x path="UInt"/></bytesTotal>
		<bytesLoaded public="1" set="null"><x path="UInt"/></bytesLoaded>
		<bytes public="1" set="null"><c path="flash.utils.ByteArray"/></bytes>
		<applicationDomain public="1" set="null"><c path="flash.system.ApplicationDomain"/></applicationDomain>
		<actionScriptVersion public="1" set="null"><e path="flash.display.ActionScriptVersion"/></actionScriptVersion>
	</class>
	<class path="flash.display.NativeMenu" params="" file="/usr/lib/haxe/std/flash/display/NativeMenu.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":require"><e>flash10_1</e></m></meta>
	</class>
	<class path="flash.display.Scene" params="" file="/usr/lib/haxe/std/flash/display/Scene.hx" extern="1">
		<numFrames public="1" set="null"><x path="Int"/></numFrames>
		<name public="1" set="null"><c path="String"/></name>
		<labels public="1" set="null"><c path="Array"><c path="flash.display.FrameLabel"/></c></labels>
		<new public="1" set="method"><f a="name:labels:numFrames">
	<c path="String"/>
	<c path="Array"><c path="flash.display.FrameLabel"/></c>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.display.Shader" params="" file="/usr/lib/haxe/std/flash/display/Shader.hx" extern="1">
		<precisionHint public="1"><e path="flash.display.ShaderPrecision"/></precisionHint>
		<data public="1"><c path="flash.display.ShaderData"/></data>
		<byteCode public="1" get="null"><c path="flash.utils.ByteArray"/></byteCode>
		<new public="1" set="method"><f a="?code">
	<c path="flash.utils.ByteArray"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.display.ShaderData" params="" file="/usr/lib/haxe/std/flash/display/ShaderData.hx" extern="1">
		<new public="1" set="method"><f a="byteCode">
	<c path="flash.utils.ByteArray"/>
	<x path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<enum path="flash.display.ShaderPrecision" params="" file="/usr/lib/haxe/std/flash/display/ShaderPrecision.hx">
		<FULL/>
		<FAST/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.SpreadMethod" params="" file="/usr/lib/haxe/std/flash/display/SpreadMethod.hx">
		<REPEAT/>
		<REFLECT/>
		<PAD/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display.Stage" params="" file="/usr/lib/haxe/std/flash/display/Stage.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<isFocusInaccessible public="1" set="method"><f a=""><x path="Bool"/></f></isFocusInaccessible>
		<invalidate public="1" set="method"><f a=""><x path="Void"/></f></invalidate>
		<wmodeGPU public="1" set="null">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</wmodeGPU>
		<stageWidth public="1"><x path="Int"/></stageWidth>
		<stageVideos public="1" set="null">
			<c path="flash.Vector"><c path="flash.media.StageVideo"/></c>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</stageVideos>
		<stageHeight public="1"><x path="Int"/></stageHeight>
		<stageFocusRect public="1"><x path="Bool"/></stageFocusRect>
		<stage3Ds public="1" set="null">
			<c path="flash.Vector"><c path="flash.display.Stage3D"/></c>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</stage3Ds>
		<softKeyboardRect public="1" set="null">
			<c path="flash.geom.Rectangle"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</softKeyboardRect>
		<showDefaultContextMenu public="1"><x path="Bool"/></showDefaultContextMenu>
		<scaleMode public="1"><e path="flash.display.StageScaleMode"/></scaleMode>
		<quality public="1"><e path="flash.display.StageQuality"/></quality>
		<fullScreenWidth public="1" set="null"><x path="UInt"/></fullScreenWidth>
		<fullScreenSourceRect public="1"><c path="flash.geom.Rectangle"/></fullScreenSourceRect>
		<fullScreenHeight public="1" set="null"><x path="UInt"/></fullScreenHeight>
		<frameRate public="1"><x path="Float"/></frameRate>
		<focus public="1"><c path="flash.display.InteractiveObject"/></focus>
		<displayState public="1"><e path="flash.display.StageDisplayState"/></displayState>
		<displayContextInfo public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</displayContextInfo>
		<colorCorrectionSupport public="1" set="null">
			<e path="flash.display.ColorCorrectionSupport"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</colorCorrectionSupport>
		<colorCorrection public="1">
			<e path="flash.display.ColorCorrection"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</colorCorrection>
		<color public="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</color>
		<allowsFullScreen public="1" set="null">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</allowsFullScreen>
		<align public="1"><e path="flash.display.StageAlign"/></align>
	</class>
	<class path="flash.display.Stage3D" params="" file="/usr/lib/haxe/std/flash/display/Stage3D.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<requestContext3D public="1" set="method"><f a="?context3DRenderMode:?profile">
	<c path="String"/>
	<e path="flash.display3D.Context3DProfile"/>
	<x path="Void"/>
</f></requestContext3D>
		<y public="1"><x path="Float"/></y>
		<x public="1"><x path="Float"/></x>
		<visible public="1"><x path="Bool"/></visible>
		<context3D public="1" set="null"><c path="flash.display3D.Context3D"/></context3D>
		<meta><m n=":require"><e>flash11</e></m></meta>
	</class>
	<enum path="flash.display.StageAlign" params="" file="/usr/lib/haxe/std/flash/display/StageAlign.hx">
		<TOP_RIGHT/>
		<TOP_LEFT/>
		<TOP/>
		<RIGHT/>
		<LEFT/>
		<BOTTOM_RIGHT/>
		<BOTTOM_LEFT/>
		<BOTTOM/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.StageDisplayState" params="" file="/usr/lib/haxe/std/flash/display/StageDisplayState.hx">
		<NORMAL/>
		<FULL_SCREEN_INTERACTIVE/>
		<FULL_SCREEN/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.StageQuality" params="" file="/usr/lib/haxe/std/flash/display/StageQuality.hx">
		<MEDIUM/>
		<LOW/>
		<HIGH_8X8_LINEAR/>
		<HIGH_8X8/>
		<HIGH_16X16_LINEAR/>
		<HIGH_16X16/>
		<HIGH/>
		<BEST/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.StageScaleMode" params="" file="/usr/lib/haxe/std/flash/display/StageScaleMode.hx">
		<SHOW_ALL/>
		<NO_SCALE/>
		<NO_BORDER/>
		<EXACT_FIT/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.TriangleCulling" params="" file="/usr/lib/haxe/std/flash/display/TriangleCulling.hx">
		<POSITIVE/>
		<NONE/>
		<NEGATIVE/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display3D.Context3D" params="" file="/usr/lib/haxe/std/flash/display3D/Context3D.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<setVertexBufferAt public="1" set="method"><f a="index:buffer:?bufferOffset:?format">
	<x path="Int"/>
	<c path="flash.display3D.VertexBuffer3D"/>
	<x path="Int"/>
	<e path="flash.display3D.Context3DVertexBufferFormat"/>
	<x path="Void"/>
</f></setVertexBufferAt>
		<setTextureAt public="1" set="method"><f a="sampler:texture">
	<x path="Int"/>
	<c path="flash.display3D.textures.TextureBase"/>
	<x path="Void"/>
</f></setTextureAt>
		<setStencilReferenceValue public="1" set="method"><f a="referenceValue:?readMask:?writeMask">
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></setStencilReferenceValue>
		<setStencilActions public="1" set="method"><f a="?triangleFace:?compareMode:?actionOnBothPass:?actionOnDepthFail:?actionOnDepthPassStencilFail">
	<e path="flash.display3D.Context3DTriangleFace"/>
	<e path="flash.display3D.Context3DCompareMode"/>
	<e path="flash.display3D.Context3DStencilAction"/>
	<e path="flash.display3D.Context3DStencilAction"/>
	<e path="flash.display3D.Context3DStencilAction"/>
	<x path="Void"/>
</f></setStencilActions>
		<setScissorRectangle public="1" set="method"><f a="rectangle">
	<c path="flash.geom.Rectangle"/>
	<x path="Void"/>
</f></setScissorRectangle>
		<setRenderToTexture public="1" set="method"><f a="texture:?enableDepthAndStencil:?antiAlias:?surfaceSelector">
	<c path="flash.display3D.textures.TextureBase"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setRenderToTexture>
		<setRenderToBackBuffer public="1" set="method"><f a=""><x path="Void"/></f></setRenderToBackBuffer>
		<setProgramConstantsFromVector public="1" set="method"><f a="programType:firstRegister:data:?numRegisters">
	<e path="flash.display3D.Context3DProgramType"/>
	<x path="Int"/>
	<c path="flash.Vector"><x path="Float"/></c>
	<x path="Int"/>
	<x path="Void"/>
</f></setProgramConstantsFromVector>
		<setProgramConstantsFromMatrix public="1" set="method"><f a="programType:firstRegister:matrix:?transposedMatrix">
	<e path="flash.display3D.Context3DProgramType"/>
	<x path="Int"/>
	<c path="flash.geom.Matrix3D"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setProgramConstantsFromMatrix>
		<setProgram public="1" set="method"><f a="program">
	<c path="flash.display3D.Program3D"/>
	<x path="Void"/>
</f></setProgram>
		<setDepthTest public="1" set="method"><f a="depthMask:passCompareMode">
	<x path="Bool"/>
	<e path="flash.display3D.Context3DCompareMode"/>
	<x path="Void"/>
</f></setDepthTest>
		<setCulling public="1" set="method"><f a="triangleFaceToCull">
	<e path="flash.display3D.Context3DTriangleFace"/>
	<x path="Void"/>
</f></setCulling>
		<setColorMask public="1" set="method"><f a="red:green:blue:alpha">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setColorMask>
		<setBlendFactors public="1" set="method"><f a="sourceFactor:destinationFactor">
	<e path="flash.display3D.Context3DBlendFactor"/>
	<e path="flash.display3D.Context3DBlendFactor"/>
	<x path="Void"/>
</f></setBlendFactors>
		<present public="1" set="method"><f a=""><x path="Void"/></f></present>
		<drawTriangles public="1" set="method"><f a="indexBuffer:?firstIndex:?numTriangles">
	<c path="flash.display3D.IndexBuffer3D"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawTriangles>
		<drawToBitmapData public="1" set="method"><f a="destination">
	<c path="flash.display.BitmapData"/>
	<x path="Void"/>
</f></drawToBitmapData>
		<dispose public="1" set="method"><f a="?recreate">
	<x path="Bool"/>
	<x path="Void"/>
</f></dispose>
		<createVertexBuffer public="1" set="method"><f a="numVertices:data32PerVertex">
	<x path="Int"/>
	<x path="Int"/>
	<c path="flash.display3D.VertexBuffer3D"/>
</f></createVertexBuffer>
		<createTexture public="1" set="method"><f a="width:height:format:optimizeForRenderToTexture:?streamingLevels">
	<x path="Int"/>
	<x path="Int"/>
	<e path="flash.display3D.Context3DTextureFormat"/>
	<x path="Bool"/>
	<x path="Int"/>
	<c path="flash.display3D.textures.Texture"/>
</f></createTexture>
		<createProgram public="1" set="method"><f a=""><c path="flash.display3D.Program3D"/></f></createProgram>
		<createIndexBuffer public="1" set="method"><f a="numIndices">
	<x path="Int"/>
	<c path="flash.display3D.IndexBuffer3D"/>
</f></createIndexBuffer>
		<createCubeTexture public="1" set="method"><f a="size:format:optimizeForRenderToTexture:?streamingLevels">
	<x path="Int"/>
	<e path="flash.display3D.Context3DTextureFormat"/>
	<x path="Bool"/>
	<x path="Int"/>
	<c path="flash.display3D.textures.CubeTexture"/>
</f></createCubeTexture>
		<configureBackBuffer public="1" set="method"><f a="width:height:antiAlias:?enableDepthAndStencil:?wantsBestResolution">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></configureBackBuffer>
		<clear public="1" set="method"><f a="?red:?green:?blue:?alpha:?depth:?stencil:?mask">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></clear>
		<enableErrorChecking public="1"><x path="Bool"/></enableErrorChecking>
		<driverInfo public="1" set="null"><c path="String"/></driverInfo>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.display3D.Context3DBlendFactor" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DBlendFactor.hx">
		<ZERO/>
		<SOURCE_COLOR/>
		<SOURCE_ALPHA/>
		<ONE_MINUS_SOURCE_COLOR/>
		<ONE_MINUS_SOURCE_ALPHA/>
		<ONE_MINUS_DESTINATION_COLOR/>
		<ONE_MINUS_DESTINATION_ALPHA/>
		<ONE/>
		<DESTINATION_COLOR/>
		<DESTINATION_ALPHA/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DCompareMode" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DCompareMode.hx">
		<NOT_EQUAL/>
		<NEVER/>
		<LESS_EQUAL/>
		<LESS/>
		<GREATER_EQUAL/>
		<GREATER/>
		<EQUAL/>
		<ALWAYS/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DMipFilter" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DMipFilter.hx">
		<MIPNONE/>
		<MIPNEAREST/>
		<MIPLINEAR/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DProfile" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DProfile.hx">
		<BASELINE_CONSTRAINED/>
		<BASELINE/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DProgramType" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DProgramType.hx">
		<VERTEX/>
		<FRAGMENT/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DStencilAction" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DStencilAction.hx">
		<ZERO/>
		<SET/>
		<KEEP/>
		<INVERT/>
		<INCREMENT_WRAP/>
		<INCREMENT_SATURATE/>
		<DECREMENT_WRAP/>
		<DECREMENT_SATURATE/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DTextureFilter" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DTextureFilter.hx">
		<NEAREST/>
		<LINEAR/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DTextureFormat" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DTextureFormat.hx">
		<COMPRESSED_ALPHA/>
		<COMPRESSED/>
		<BGR_PACKED/>
		<BGRA_PACKED/>
		<BGRA/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DTriangleFace" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DTriangleFace.hx">
		<NONE/>
		<FRONT_AND_BACK/>
		<FRONT/>
		<BACK/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DVertexBufferFormat" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DVertexBufferFormat.hx">
		<FLOAT_4/>
		<FLOAT_3/>
		<FLOAT_2/>
		<FLOAT_1/>
		<BYTES_4/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DWrapMode" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DWrapMode.hx">
		<REPEAT/>
		<CLAMP/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display3D.IndexBuffer3D" params="" file="/usr/lib/haxe/std/flash/display3D/IndexBuffer3D.hx" extern="1">
		<uploadFromVector public="1" set="method"><f a="data:startOffset:count">
	<c path="flash.Vector"><x path="UInt"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadFromVector>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:startOffset:count">
	<c path="flash.utils.ByteArray"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadFromByteArray>
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.display3D.Program3D" params="" file="/usr/lib/haxe/std/flash/display3D/Program3D.hx" extern="1">
		<upload public="1" set="method"><f a="vertexProgram:fragmentProgram">
	<c path="flash.utils.ByteArray"/>
	<c path="flash.utils.ByteArray"/>
	<x path="Void"/>
</f></upload>
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.display3D.VertexBuffer3D" params="" file="/usr/lib/haxe/std/flash/display3D/VertexBuffer3D.hx" extern="1">
		<uploadFromVector public="1" set="method"><f a="data:startVertex:numVertices">
	<c path="flash.Vector"><x path="Float"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadFromVector>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:startVertex:numVertices">
	<c path="flash.utils.ByteArray"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadFromByteArray>
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
	</class>
	<class path="flash.display3D.textures.TextureBase" params="" file="/usr/lib/haxe/std/flash/display3D/textures/TextureBase.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
	</class>
	<class path="flash.display3D.textures.CubeTexture" params="" file="/usr/lib/haxe/std/flash/display3D/textures/CubeTexture.hx" extern="1">
		<extends path="flash.display3D.textures.TextureBase"/>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:side:?miplevel">
	<c path="flash.utils.ByteArray"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></uploadFromByteArray>
		<uploadFromBitmapData public="1" set="method"><f a="source:side:?miplevel">
	<c path="flash.display.BitmapData"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></uploadFromBitmapData>
		<uploadCompressedTextureFromByteArray public="1" set="method"><f a="data:byteArrayOffset:?async">
	<c path="flash.utils.ByteArray"/>
	<x path="UInt"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></uploadCompressedTextureFromByteArray>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.display3D.textures.Texture" params="" file="/usr/lib/haxe/std/flash/display3D/textures/Texture.hx" extern="1">
		<extends path="flash.display3D.textures.TextureBase"/>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:?miplevel">
	<c path="flash.utils.ByteArray"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></uploadFromByteArray>
		<uploadFromBitmapData public="1" set="method"><f a="source:?miplevel">
	<c path="flash.display.BitmapData"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></uploadFromBitmapData>
		<uploadCompressedTextureFromByteArray public="1" set="method"><f a="data:byteArrayOffset:?async">
	<c path="flash.utils.ByteArray"/>
	<x path="UInt"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></uploadCompressedTextureFromByteArray>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.errors.Error" params="" file="/usr/lib/haxe/std/flash/errors/Error.hx" extern="1">
		<length public="1" static="1"><x path="Int"/></length>
		<getErrorMessage public="1" set="method" static="1"><f a="index">
	<x path="Int"/>
	<c path="String"/>
</f></getErrorMessage>
		<throwError public="1" set="method" static="1"><f a="type:index:?p1:?p2:?p3:?p4:?p5">
	<x path="Class"><d/></x>
	<x path="UInt"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
</f></throwError>
		<getStackTrace public="1" set="method"><f a=""><c path="String"/></f></getStackTrace>
		<name public="1"><d/></name>
		<message public="1"><d/></message>
		<errorID public="1" set="null"><x path="Int"/></errorID>
		<new public="1" set="method"><f a="?message:?id">
	<d/>
	<d/>
	<x path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.events.Event" params="" file="/usr/lib/haxe/std/flash/events/Event.hx" extern="1">
		<ACTIVATE public="1" static="1"><c path="String"/></ACTIVATE>
		<ADDED public="1" static="1"><c path="String"/></ADDED>
		<ADDED_TO_STAGE public="1" static="1"><c path="String"/></ADDED_TO_STAGE>
		<CANCEL public="1" static="1"><c path="String"/></CANCEL>
		<CHANGE public="1" static="1"><c path="String"/></CHANGE>
		<CHANNEL_MESSAGE public="1" static="1"><c path="String"/></CHANNEL_MESSAGE>
		<CHANNEL_STATE public="1" static="1"><c path="String"/></CHANNEL_STATE>
		<CLEAR public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</CLEAR>
		<CLOSE public="1" static="1"><c path="String"/></CLOSE>
		<COMPLETE public="1" static="1"><c path="String"/></COMPLETE>
		<CONNECT public="1" static="1"><c path="String"/></CONNECT>
		<CONTEXT3D_CREATE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</CONTEXT3D_CREATE>
		<COPY public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</COPY>
		<CUT public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</CUT>
		<DEACTIVATE public="1" static="1"><c path="String"/></DEACTIVATE>
		<ENTER_FRAME public="1" static="1"><c path="String"/></ENTER_FRAME>
		<EXIT_FRAME public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</EXIT_FRAME>
		<FRAME_CONSTRUCTED public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</FRAME_CONSTRUCTED>
		<FULLSCREEN public="1" static="1"><c path="String"/></FULLSCREEN>
		<ID3 public="1" static="1"><c path="String"/></ID3>
		<INIT public="1" static="1"><c path="String"/></INIT>
		<MOUSE_LEAVE public="1" static="1"><c path="String"/></MOUSE_LEAVE>
		<OPEN public="1" static="1"><c path="String"/></OPEN>
		<PASTE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</PASTE>
		<REMOVED public="1" static="1"><c path="String"/></REMOVED>
		<REMOVED_FROM_STAGE public="1" static="1"><c path="String"/></REMOVED_FROM_STAGE>
		<RENDER public="1" static="1"><c path="String"/></RENDER>
		<RESIZE public="1" static="1"><c path="String"/></RESIZE>
		<SCROLL public="1" static="1"><c path="String"/></SCROLL>
		<SELECT public="1" static="1"><c path="String"/></SELECT>
		<SELECT_ALL public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</SELECT_ALL>
		<SOUND_COMPLETE public="1" static="1"><c path="String"/></SOUND_COMPLETE>
		<TAB_CHILDREN_CHANGE public="1" static="1"><c path="String"/></TAB_CHILDREN_CHANGE>
		<TAB_ENABLED_CHANGE public="1" static="1"><c path="String"/></TAB_ENABLED_CHANGE>
		<TAB_INDEX_CHANGE public="1" static="1"><c path="String"/></TAB_INDEX_CHANGE>
		<TEXT_INTERACTION_MODE_CHANGE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</TEXT_INTERACTION_MODE_CHANGE>
		<UNLOAD public="1" static="1"><c path="String"/></UNLOAD>
		<VIDEO_FRAME public="1" static="1"><c path="String"/></VIDEO_FRAME>
		<WORKER_STATE public="1" static="1"><c path="String"/></WORKER_STATE>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<stopPropagation public="1" set="method"><f a=""><x path="Void"/></f></stopPropagation>
		<stopImmediatePropagation public="1" set="method"><f a=""><x path="Void"/></f></stopImmediatePropagation>
		<preventDefault public="1" set="method"><f a=""><x path="Void"/></f></preventDefault>
		<isDefaultPrevented public="1" set="method"><f a=""><x path="Bool"/></f></isDefaultPrevented>
		<formatToString public="1" set="method"><f a="className:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<c path="String"/>
</f></formatToString>
		<clone public="1" set="method"><f a=""><c path="flash.events.Event"/></f></clone>
		<type public="1" set="null"><c path="String"/></type>
		<target public="1" set="null"><d/></target>
		<eventPhase public="1" set="null"><e path="flash.events.EventPhase"/></eventPhase>
		<currentTarget public="1" set="null"><d/></currentTarget>
		<cancelable public="1" set="null"><x path="Bool"/></cancelable>
		<bubbles public="1" set="null"><x path="Bool"/></bubbles>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="flash.events.EventPhase" params="" file="/usr/lib/haxe/std/flash/events/EventPhase.hx">
		<CAPTURING_PHASE/>
		<BUBBLING_PHASE/>
		<AT_TARGET/>
		<meta><m n=":fakeEnum"><e>UInt</e></m></meta>
	</enum>
	<class path="flash.events.UncaughtErrorEvents" params="" file="/usr/lib/haxe/std/flash/events/UncaughtErrorEvents.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":require"><e>flash10_1</e></m></meta>
	</class>
	<class path="flash.external.ExternalInterface" params="" file="/usr/lib/haxe/std/flash/external/ExternalInterface.hx" extern="1">
		<available public="1" set="null" static="1"><x path="Bool"/></available>
		<marshallExceptions public="1" static="1"><x path="Bool"/></marshallExceptions>
		<objectID public="1" set="null" static="1"><c path="String"/></objectID>
		<addCallback public="1" set="method" static="1"><f a="functionName:closure">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></addCallback>
		<call public="1" set="method" static="1"><f a="functionName:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
</f></call>
	</class>
	<class path="flash.filters.BitmapFilter" params="" file="/usr/lib/haxe/std/flash/filters/BitmapFilter.hx" extern="1">
		<clone public="1" set="method"><f a=""><c path="flash.filters.BitmapFilter"/></f></clone>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.filters.GlowFilter" params="" file="/usr/lib/haxe/std/flash/filters/GlowFilter.hx" extern="1">
		<extends path="flash.filters.BitmapFilter"/>
		<strength public="1"><x path="Float"/></strength>
		<quality public="1"><x path="Int"/></quality>
		<knockout public="1"><x path="Bool"/></knockout>
		<inner public="1"><x path="Bool"/></inner>
		<color public="1"><x path="UInt"/></color>
		<blurY public="1"><x path="Float"/></blurY>
		<blurX public="1"><x path="Float"/></blurX>
		<alpha public="1"><x path="Float"/></alpha>
		<new public="1" set="method"><f a="?color:?alpha:?blurX:?blurY:?strength:?quality:?inner:?knockout">
	<x path="UInt"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.geom.ColorTransform" params="" file="/usr/lib/haxe/std/flash/geom/ColorTransform.hx" extern="1">
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<concat public="1" set="method"><f a="second">
	<c path="flash.geom.ColorTransform"/>
	<x path="Void"/>
</f></concat>
		<redOffset public="1"><x path="Float"/></redOffset>
		<redMultiplier public="1"><x path="Float"/></redMultiplier>
		<greenOffset public="1"><x path="Float"/></greenOffset>
		<greenMultiplier public="1"><x path="Float"/></greenMultiplier>
		<color public="1"><x path="UInt"/></color>
		<blueOffset public="1"><x path="Float"/></blueOffset>
		<blueMultiplier public="1"><x path="Float"/></blueMultiplier>
		<alphaOffset public="1"><x path="Float"/></alphaOffset>
		<alphaMultiplier public="1"><x path="Float"/></alphaMultiplier>
		<new public="1" set="method"><f a="?redMultiplier:?greenMultiplier:?blueMultiplier:?alphaMultiplier:?redOffset:?greenOffset:?blueOffset:?alphaOffset">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Matrix" params="" file="/usr/lib/haxe/std/flash/geom/Matrix.hx" extern="1">
		<translate public="1" set="method"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></translate>
		<transformPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></transformPoint>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<setTo public="1" set="method">
			<f a="aa:ba:ca:da:txa:tya">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</setTo>
		<scale public="1" set="method"><f a="sx:sy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></scale>
		<rotate public="1" set="method"><f a="angle">
	<x path="Float"/>
	<x path="Void"/>
</f></rotate>
		<invert public="1" set="method"><f a=""><x path="Void"/></f></invert>
		<identity public="1" set="method"><f a=""><x path="Void"/></f></identity>
		<deltaTransformPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></deltaTransformPoint>
		<createGradientBox public="1" set="method"><f a="width:height:?rotation:?tx:?ty">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></createGradientBox>
		<createBox public="1" set="method"><f a="scaleX:scaleY:?rotation:?tx:?ty">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></createBox>
		<copyRowTo public="1" set="method">
			<f a="row:vector3D">
				<x path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRowTo>
		<copyRowFrom public="1" set="method">
			<f a="row:vector3D">
				<x path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRowFrom>
		<copyFrom public="1" set="method">
			<f a="sourceMatrix">
				<c path="flash.geom.Matrix"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<copyColumnTo public="1" set="method">
			<f a="column:vector3D">
				<x path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyColumnTo>
		<copyColumnFrom public="1" set="method">
			<f a="column:vector3D">
				<x path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyColumnFrom>
		<concat public="1" set="method"><f a="m">
	<c path="flash.geom.Matrix"/>
	<x path="Void"/>
</f></concat>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Matrix"/></f></clone>
		<ty public="1"><x path="Float"/></ty>
		<tx public="1"><x path="Float"/></tx>
		<d public="1"><x path="Float"/></d>
		<c public="1"><x path="Float"/></c>
		<b public="1"><x path="Float"/></b>
		<a public="1"><x path="Float"/></a>
		<new public="1" set="method"><f a="?a:?b:?c:?d:?tx:?ty">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Matrix3D" params="" file="/usr/lib/haxe/std/flash/geom/Matrix3D.hx" extern="1">
		<interpolate public="1" set="method" static="1"><f a="thisMat:toMat:percent">
	<c path="flash.geom.Matrix3D"/>
	<c path="flash.geom.Matrix3D"/>
	<x path="Float"/>
	<c path="flash.geom.Matrix3D"/>
</f></interpolate>
		<transpose public="1" set="method"><f a=""><x path="Void"/></f></transpose>
		<transformVectors public="1" set="method"><f a="vin:vout">
	<c path="flash.Vector"><x path="Float"/></c>
	<c path="flash.Vector"><x path="Float"/></c>
	<x path="Void"/>
</f></transformVectors>
		<transformVector public="1" set="method"><f a="v">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></transformVector>
		<recompose public="1" set="method"><f a="components:?orientationStyle">
	<c path="flash.Vector"><c path="flash.geom.Vector3D"/></c>
	<e path="flash.geom.Orientation3D"/>
	<x path="Bool"/>
</f></recompose>
		<prependTranslation public="1" set="method"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></prependTranslation>
		<prependScale public="1" set="method"><f a="xScale:yScale:zScale">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></prependScale>
		<prependRotation public="1" set="method"><f a="degrees:axis:?pivotPoint">
	<x path="Float"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></prependRotation>
		<prepend public="1" set="method"><f a="rhs">
	<c path="flash.geom.Matrix3D"/>
	<x path="Void"/>
</f></prepend>
		<pointAt public="1" set="method"><f a="pos:?at:?up">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></pointAt>
		<invert public="1" set="method"><f a=""><x path="Bool"/></f></invert>
		<interpolateTo public="1" set="method"><f a="toMat:percent">
	<c path="flash.geom.Matrix3D"/>
	<x path="Float"/>
	<x path="Void"/>
</f></interpolateTo>
		<identity public="1" set="method"><f a=""><x path="Void"/></f></identity>
		<deltaTransformVector public="1" set="method"><f a="v">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></deltaTransformVector>
		<decompose public="1" set="method"><f a="?orientationStyle">
	<e path="flash.geom.Orientation3D"/>
	<c path="flash.Vector"><c path="flash.geom.Vector3D"/></c>
</f></decompose>
		<copyToMatrix3D public="1" set="method">
			<f a="dest">
				<c path="flash.geom.Matrix3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyToMatrix3D>
		<copyRowTo public="1" set="method">
			<f a="row:vector3D">
				<x path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRowTo>
		<copyRowFrom public="1" set="method">
			<f a="row:vector3D">
				<x path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRowFrom>
		<copyRawDataTo public="1" set="method">
			<f a="vector:?index:?transpose">
				<c path="flash.Vector"><x path="Float"/></c>
				<x path="UInt"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRawDataTo>
		<copyRawDataFrom public="1" set="method">
			<f a="vector:?index:?transpose">
				<c path="flash.Vector"><x path="Float"/></c>
				<x path="UInt"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRawDataFrom>
		<copyFrom public="1" set="method">
			<f a="sourceMatrix3D">
				<c path="flash.geom.Matrix3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<copyColumnTo public="1" set="method">
			<f a="column:vector3D">
				<x path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyColumnTo>
		<copyColumnFrom public="1" set="method">
			<f a="column:vector3D">
				<x path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyColumnFrom>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Matrix3D"/></f></clone>
		<appendTranslation public="1" set="method"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></appendTranslation>
		<appendScale public="1" set="method"><f a="xScale:yScale:zScale">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></appendScale>
		<appendRotation public="1" set="method"><f a="degrees:axis:?pivotPoint">
	<x path="Float"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></appendRotation>
		<append public="1" set="method"><f a="lhs">
	<c path="flash.geom.Matrix3D"/>
	<x path="Void"/>
</f></append>
		<rawData public="1"><c path="flash.Vector"><x path="Float"/></c></rawData>
		<position public="1"><c path="flash.geom.Vector3D"/></position>
		<determinant public="1" set="null"><x path="Float"/></determinant>
		<new public="1" set="method"><f a="?v">
	<c path="flash.Vector"><x path="Float"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<enum path="flash.geom.Orientation3D" params="" file="/usr/lib/haxe/std/flash/geom/Orientation3D.hx">
		<QUATERNION/>
		<EULER_ANGLES/>
		<AXIS_ANGLE/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.geom.PerspectiveProjection" params="" file="/usr/lib/haxe/std/flash/geom/PerspectiveProjection.hx" extern="1">
		<toMatrix3D public="1" set="method"><f a=""><c path="flash.geom.Matrix3D"/></f></toMatrix3D>
		<projectionCenter public="1"><c path="flash.geom.Point"/></projectionCenter>
		<focalLength public="1"><x path="Float"/></focalLength>
		<fieldOfView public="1"><x path="Float"/></fieldOfView>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.geom.Point" params="" file="/usr/lib/haxe/std/flash/geom/Point.hx" extern="1">
		<distance public="1" set="method" static="1"><f a="pt1:pt2">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
	<x path="Float"/>
</f></distance>
		<interpolate public="1" set="method" static="1"><f a="pt1:pt2:f">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
	<x path="Float"/>
	<c path="flash.geom.Point"/>
</f></interpolate>
		<polar public="1" set="method" static="1"><f a="len:angle">
	<x path="Float"/>
	<x path="Float"/>
	<c path="flash.geom.Point"/>
</f></polar>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<subtract public="1" set="method"><f a="v">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></subtract>
		<setTo public="1" set="method">
			<f a="xa:ya">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</setTo>
		<offset public="1" set="method"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></offset>
		<normalize public="1" set="method"><f a="thickness">
	<x path="Float"/>
	<x path="Void"/>
</f></normalize>
		<equals public="1" set="method"><f a="toCompare">
	<c path="flash.geom.Point"/>
	<x path="Bool"/>
</f></equals>
		<copyFrom public="1" set="method">
			<f a="sourcePoint">
				<c path="flash.geom.Point"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Point"/></f></clone>
		<add public="1" set="method"><f a="v">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></add>
		<y public="1"><x path="Float"/></y>
		<x public="1"><x path="Float"/></x>
		<length public="1" set="null"><x path="Float"/></length>
		<new public="1" set="method"><f a="?x:?y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Rectangle" params="" file="/usr/lib/haxe/std/flash/geom/Rectangle.hx" extern="1">
		<union public="1" set="method"><f a="toUnion">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></union>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<setTo public="1" set="method">
			<f a="xa:ya:widtha:heighta">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</setTo>
		<setEmpty public="1" set="method"><f a=""><x path="Void"/></f></setEmpty>
		<offsetPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<x path="Void"/>
</f></offsetPoint>
		<offset public="1" set="method"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></offset>
		<isEmpty public="1" set="method"><f a=""><x path="Bool"/></f></isEmpty>
		<intersects public="1" set="method"><f a="toIntersect">
	<c path="flash.geom.Rectangle"/>
	<x path="Bool"/>
</f></intersects>
		<intersection public="1" set="method"><f a="toIntersect">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></intersection>
		<inflatePoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<x path="Void"/>
</f></inflatePoint>
		<inflate public="1" set="method"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></inflate>
		<equals public="1" set="method"><f a="toCompare">
	<c path="flash.geom.Rectangle"/>
	<x path="Bool"/>
</f></equals>
		<copyFrom public="1" set="method">
			<f a="sourceRect">
				<c path="flash.geom.Rectangle"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<containsRect public="1" set="method"><f a="rect">
	<c path="flash.geom.Rectangle"/>
	<x path="Bool"/>
</f></containsRect>
		<containsPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<x path="Bool"/>
</f></containsPoint>
		<contains public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></contains>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Rectangle"/></f></clone>
		<y public="1"><x path="Float"/></y>
		<x public="1"><x path="Float"/></x>
		<width public="1"><x path="Float"/></width>
		<topLeft public="1"><c path="flash.geom.Point"/></topLeft>
		<top public="1"><x path="Float"/></top>
		<size public="1"><c path="flash.geom.Point"/></size>
		<right public="1"><x path="Float"/></right>
		<left public="1"><x path="Float"/></left>
		<height public="1"><x path="Float"/></height>
		<bottomRight public="1"><c path="flash.geom.Point"/></bottomRight>
		<bottom public="1"><x path="Float"/></bottom>
		<new public="1" set="method"><f a="?x:?y:?width:?height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Transform" params="" file="/usr/lib/haxe/std/flash/geom/Transform.hx" extern="1">
		<getRelativeMatrix3D public="1" set="method">
			<f a="relativeTo">
				<c path="flash.display.DisplayObject"/>
				<c path="flash.geom.Matrix3D"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</getRelativeMatrix3D>
		<pixelBounds public="1" set="null"><c path="flash.geom.Rectangle"/></pixelBounds>
		<perspectiveProjection public="1">
			<c path="flash.geom.PerspectiveProjection"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</perspectiveProjection>
		<matrix3D public="1">
			<c path="flash.geom.Matrix3D"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</matrix3D>
		<matrix public="1"><c path="flash.geom.Matrix"/></matrix>
		<concatenatedMatrix public="1" set="null"><c path="flash.geom.Matrix"/></concatenatedMatrix>
		<concatenatedColorTransform public="1" set="null"><c path="flash.geom.ColorTransform"/></concatenatedColorTransform>
		<colorTransform public="1"><c path="flash.geom.ColorTransform"/></colorTransform>
		<new public="1" set="method"><f a="displayObject">
	<c path="flash.display.DisplayObject"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Vector3D" params="" file="/usr/lib/haxe/std/flash/geom/Vector3D.hx" extern="1">
		<X_AXIS public="1" static="1"><c path="flash.geom.Vector3D"/></X_AXIS>
		<Y_AXIS public="1" static="1"><c path="flash.geom.Vector3D"/></Y_AXIS>
		<Z_AXIS public="1" static="1"><c path="flash.geom.Vector3D"/></Z_AXIS>
		<angleBetween public="1" set="method" static="1"><f a="a:b">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<x path="Float"/>
</f></angleBetween>
		<distance public="1" set="method" static="1"><f a="pt1:pt2">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<x path="Float"/>
</f></distance>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<subtract public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></subtract>
		<setTo public="1" set="method">
			<f a="xa:ya:za">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</setTo>
		<scaleBy public="1" set="method"><f a="s">
	<x path="Float"/>
	<x path="Void"/>
</f></scaleBy>
		<project public="1" set="method"><f a=""><x path="Void"/></f></project>
		<normalize public="1" set="method"><f a=""><x path="Float"/></f></normalize>
		<negate public="1" set="method"><f a=""><x path="Void"/></f></negate>
		<nearEquals public="1" set="method"><f a="toCompare:tolerance:?allFour">
	<c path="flash.geom.Vector3D"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></nearEquals>
		<incrementBy public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></incrementBy>
		<equals public="1" set="method"><f a="toCompare:?allFour">
	<c path="flash.geom.Vector3D"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></equals>
		<dotProduct public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<x path="Float"/>
</f></dotProduct>
		<decrementBy public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></decrementBy>
		<crossProduct public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></crossProduct>
		<copyFrom public="1" set="method">
			<f a="sourceVector3D">
				<c path="flash.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Vector3D"/></f></clone>
		<add public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></add>
		<z public="1"><x path="Float"/></z>
		<y public="1"><x path="Float"/></y>
		<x public="1"><x path="Float"/></x>
		<w public="1"><x path="Float"/></w>
		<lengthSquared public="1" set="null"><x path="Float"/></lengthSquared>
		<length public="1" set="null"><x path="Float"/></length>
		<new public="1" set="method"><f a="?x:?y:?z:?w">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.media.AVCaptionStyle" params="" file="/usr/lib/haxe/std/flash/media/AVCaptionStyle.hx" extern="1">
		<BLACK public="1" static="1"><c path="String"/></BLACK>
		<BLUE public="1" static="1"><c path="String"/></BLUE>
		<BRIGHT_BLUE public="1" static="1"><c path="String"/></BRIGHT_BLUE>
		<BRIGHT_CYAN public="1" static="1"><c path="String"/></BRIGHT_CYAN>
		<BRIGHT_GREEN public="1" static="1"><c path="String"/></BRIGHT_GREEN>
		<BRIGHT_MAGENTA public="1" static="1"><c path="String"/></BRIGHT_MAGENTA>
		<BRIGHT_RED public="1" static="1"><c path="String"/></BRIGHT_RED>
		<BRIGHT_WHITE public="1" static="1"><c path="String"/></BRIGHT_WHITE>
		<BRIGHT_YELLOW public="1" static="1"><c path="String"/></BRIGHT_YELLOW>
		<CASUAL public="1" static="1"><c path="String"/></CASUAL>
		<CURSIVE public="1" static="1"><c path="String"/></CURSIVE>
		<CYAN public="1" static="1"><c path="String"/></CYAN>
		<DARK_BLUE public="1" static="1"><c path="String"/></DARK_BLUE>
		<DARK_CYAN public="1" static="1"><c path="String"/></DARK_CYAN>
		<DARK_GREEN public="1" static="1"><c path="String"/></DARK_GREEN>
		<DARK_MAGENTA public="1" static="1"><c path="String"/></DARK_MAGENTA>
		<DARK_RED public="1" static="1"><c path="String"/></DARK_RED>
		<DARK_YELLOW public="1" static="1"><c path="String"/></DARK_YELLOW>
		<DEFAULT public="1" static="1"><c path="String"/></DEFAULT>
		<DEPRESSED public="1" static="1"><c path="String"/></DEPRESSED>
		<GRAY public="1" static="1"><c path="String"/></GRAY>
		<GREEN public="1" static="1"><c path="String"/></GREEN>
		<LARGE public="1" static="1"><c path="String"/></LARGE>
		<LEFT_DROP_SHADOW public="1" static="1"><c path="String"/></LEFT_DROP_SHADOW>
		<MAGENTA public="1" static="1"><c path="String"/></MAGENTA>
		<MEDIUM public="1" static="1"><c path="String"/></MEDIUM>
		<MONOSPACED_WITHOUT_SERIFS public="1" static="1"><c path="String"/></MONOSPACED_WITHOUT_SERIFS>
		<MONOSPACE_WITH_SERIFS public="1" static="1"><c path="String"/></MONOSPACE_WITH_SERIFS>
		<NONE public="1" static="1"><c path="String"/></NONE>
		<PROPORTIONAL_WITHOUT_SERIFS public="1" static="1"><c path="String"/></PROPORTIONAL_WITHOUT_SERIFS>
		<PROPORTIONAL_WITH_SERIFS public="1" static="1"><c path="String"/></PROPORTIONAL_WITH_SERIFS>
		<RAISED public="1" static="1"><c path="String"/></RAISED>
		<RED public="1" static="1"><c path="String"/></RED>
		<RIGHT_DROP_SHADOW public="1" static="1"><c path="String"/></RIGHT_DROP_SHADOW>
		<SMALL public="1" static="1"><c path="String"/></SMALL>
		<SMALL_CAPITALS public="1" static="1"><c path="String"/></SMALL_CAPITALS>
		<UNIFORM public="1" static="1"><c path="String"/></UNIFORM>
		<WHITE public="1" static="1"><c path="String"/></WHITE>
		<YELLOW public="1" static="1"><c path="String"/></YELLOW>
		<size public="1"><c path="String"/></size>
		<fontOpacity public="1"><c path="String"/></fontOpacity>
		<fontEdge public="1"><c path="String"/></fontEdge>
		<fontColor public="1"><c path="String"/></fontColor>
		<font public="1"><c path="String"/></font>
		<fillOpacity public="1"><c path="String"/></fillOpacity>
		<fillColor public="1"><c path="String"/></fillColor>
		<edgeColor public="1"><c path="String"/></edgeColor>
		<backgroundOpacity public="1"><c path="String"/></backgroundOpacity>
		<backgroundColor public="1"><c path="String"/></backgroundColor>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.media.AVPlayState" params="" file="/usr/lib/haxe/std/flash/media/AVPlayState.hx" extern="1">
		<BUFFERING public="1" static="1"><x path="Int"/></BUFFERING>
		<EOF public="1" static="1"><x path="Int"/></EOF>
		<PAUSED public="1" static="1"><x path="Int"/></PAUSED>
		<PLAYING public="1" static="1"><x path="Int"/></PLAYING>
		<READY public="1" static="1"><x path="Int"/></READY>
		<SUSPENDED public="1" static="1"><x path="Int"/></SUSPENDED>
		<UNINITIALIZED public="1" static="1"><x path="Int"/></UNINITIALIZED>
		<UNRECOVERABLE_ERROR public="1" static="1"><x path="Int"/></UNRECOVERABLE_ERROR>
		<state public="1" set="null"><x path="Int"/></state>
		<new public="1" set="method"><f a="state">
	<x path="UInt"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.media.AVResult" params="" file="/usr/lib/haxe/std/flash/media/AVResult.hx" extern="1">
		<ASYNC_OPERATION_IN_PROGRESS public="1" static="1"><x path="Int"/></ASYNC_OPERATION_IN_PROGRESS>
		<BAD_MANIFEST_SIGNATURE public="1" static="1"><x path="Int"/></BAD_MANIFEST_SIGNATURE>
		<BAD_MEDIA_INTERLEAVING public="1" static="1"><x path="Int"/></BAD_MEDIA_INTERLEAVING>
		<CALLED_FROM_WRONG_THREAD public="1" static="1"><x path="Int"/></CALLED_FROM_WRONG_THREAD>
		<CANNOT_FAIL_OVER public="1" static="1"><x path="Int"/></CANNOT_FAIL_OVER>
		<CANNOT_LOAD_PLAY_LIST public="1" static="1"><x path="Int"/></CANNOT_LOAD_PLAY_LIST>
		<CODEC_NOT_SUPPORTED public="1" static="1"><x path="Int"/></CODEC_NOT_SUPPORTED>
		<COMPONENT_CREATION_FAILURE public="1" static="1"><x path="Int"/></COMPONENT_CREATION_FAILURE>
		<CONTAINER_NOT_SUPPORTED public="1" static="1"><x path="Int"/></CONTAINER_NOT_SUPPORTED>
		<CONTENT_LENGTH_MISMATCH public="1" static="1"><x path="Int"/></CONTENT_LENGTH_MISMATCH>
		<CURRENT_PERIOD_EXPIRED public="1" static="1"><x path="Int"/></CURRENT_PERIOD_EXPIRED>
		<DECODER_FAILED public="1" static="1"><x path="Int"/></DECODER_FAILED>
		<DEVICE_OPEN_ERROR public="1" static="1"><x path="Int"/></DEVICE_OPEN_ERROR>
		<DRM_INIT_ERROR public="1" static="1"><x path="Int"/></DRM_INIT_ERROR>
		<DRM_NOT_AVAILABLE public="1" static="1"><x path="Int"/></DRM_NOT_AVAILABLE>
		<EOF public="1" static="1"><x path="Int"/></EOF>
		<FILE_NOT_FOUND public="1" static="1"><x path="Int"/></FILE_NOT_FOUND>
		<FILE_STRUCTURE_INVALID public="1" static="1"><x path="Int"/></FILE_STRUCTURE_INVALID>
		<FRAGMENT_READ_ERROR public="1" static="1"><x path="Int"/></FRAGMENT_READ_ERROR>
		<GENERIC_ERROR public="1" static="1"><x path="Int"/></GENERIC_ERROR>
		<HTTP_TIME_OUT public="1" static="1"><x path="Int"/></HTTP_TIME_OUT>
		<INVALID_OPERATION public="1" static="1"><x path="Int"/></INVALID_OPERATION>
		<INVALID_PARAMETER public="1" static="1"><x path="Int"/></INVALID_PARAMETER>
		<INVALID_REPLACE_DURATION public="1" static="1"><x path="Int"/></INVALID_REPLACE_DURATION>
		<INVALID_SEEK_TIME public="1" static="1"><x path="Int"/></INVALID_SEEK_TIME>
		<INVALID_WITH_AUDIO_ONLY_FILE public="1" static="1"><x path="Int"/></INVALID_WITH_AUDIO_ONLY_FILE>
		<IRRECOVERABLE_ERROR public="1" static="1"><x path="Int"/></IRRECOVERABLE_ERROR>
		<LIVE_HOLD public="1" static="1"><x path="Int"/></LIVE_HOLD>
		<LIVE_WINDOW_MOVED_BACKWARD public="1" static="1"><x path="Int"/></LIVE_WINDOW_MOVED_BACKWARD>
		<LOST_CONNECTION_RECOVERABLE public="1" static="1"><x path="Int"/></LOST_CONNECTION_RECOVERABLE>
		<NETWORK_DOWN public="1" static="1"><x path="Int"/></NETWORK_DOWN>
		<NETWORK_ERROR public="1" static="1"><x path="Int"/></NETWORK_ERROR>
		<NETWORK_UNAVAILABLE public="1" static="1"><x path="Int"/></NETWORK_UNAVAILABLE>
		<NOT_IMPLEMENTED public="1" static="1"><x path="Int"/></NOT_IMPLEMENTED>
		<NO_FIXED_SIZE public="1" static="1"><x path="Int"/></NO_FIXED_SIZE>
		<NO_USEABLE_BITRATE_PROFILE public="1" static="1"><x path="Int"/></NO_USEABLE_BITRATE_PROFILE>
		<ONLY_ALLOWED_IN_PAUSED_STATE public="1" static="1"><x path="Int"/></ONLY_ALLOWED_IN_PAUSED_STATE>
		<OPERATION_ABORTED public="1" static="1"><x path="Int"/></OPERATION_ABORTED>
		<OUT_OF_MEMORY public="1" static="1"><x path="Int"/></OUT_OF_MEMORY>
		<OVERFLOW public="1" static="1"><x path="Int"/></OVERFLOW>
		<PARSE_ERROR public="1" static="1"><x path="Int"/></PARSE_ERROR>
		<PERIOD_HOLD public="1" static="1"><x path="Int"/></PERIOD_HOLD>
		<PERIOD_NOT_LOADED public="1" static="1"><x path="Int"/></PERIOD_NOT_LOADED>
		<PLAYBACK_NOT_ENABLED public="1" static="1"><x path="Int"/></PLAYBACK_NOT_ENABLED>
		<PREVIOUS_STEP_SEEK_IN_PROGRESS public="1" static="1"><x path="Int"/></PREVIOUS_STEP_SEEK_IN_PROGRESS>
		<RANGE_ERROR public="1" static="1"><x path="Int"/></RANGE_ERROR>
		<REPLACEMENT_FAILED public="1" static="1"><x path="Int"/></REPLACEMENT_FAILED>
		<RESOURCE_NOT_SPECIFIED public="1" static="1"><x path="Int"/></RESOURCE_NOT_SPECIFIED>
		<SEEK_FAILED public="1" static="1"><x path="Int"/></SEEK_FAILED>
		<SIZE_UNKNOWN public="1" static="1"><x path="Int"/></SIZE_UNKNOWN>
		<SUCCESS public="1" static="1"><x path="Int"/></SUCCESS>
		<SWITCH_TO_ASYMMETRIC_PROFILE public="1" static="1"><x path="Int"/></SWITCH_TO_ASYMMETRIC_PROFILE>
		<UNDERFLOW public="1" static="1"><x path="Int"/></UNDERFLOW>
		<UNSUPPORTED_CONFIGURATION public="1" static="1"><x path="Int"/></UNSUPPORTED_CONFIGURATION>
		<UNSUPPORTED_HLS_VERSION public="1" static="1"><x path="Int"/></UNSUPPORTED_HLS_VERSION>
		<UNSUPPORTED_OPERATION public="1" static="1"><x path="Int"/></UNSUPPORTED_OPERATION>
		<VIDEO_PROFILE_NOT_SUPPORTED public="1" static="1"><x path="Int"/></VIDEO_PROFILE_NOT_SUPPORTED>
		<WAITING_FOR_INIT public="1" static="1"><x path="Int"/></WAITING_FOR_INIT>
		<result public="1" set="null"><x path="Int"/></result>
		<new public="1" set="method"><f a="inResult">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.media.AVSource" params="" file="/usr/lib/haxe/std/flash/media/AVSource.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.media.AVStream" params="" file="/usr/lib/haxe/std/flash/media/AVStream.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<HARDWARE public="1" static="1"><c path="String"/></HARDWARE>
		<SOFTWARE public="1" static="1"><c path="String"/></SOFTWARE>
		<UNDEFINED public="1" static="1"><c path="String"/></UNDEFINED>
		<step public="1" set="method"><f a="frames">
	<x path="Int"/>
	<c path="flash.media.AVResult"/>
</f></step>
		<seekToLocalTime public="1" set="method"><f a="periodIndex:time">
	<x path="Int"/>
	<x path="Float"/>
	<c path="flash.media.AVResult"/>
</f></seekToLocalTime>
		<seekToLivePoint public="1" set="method"><f a=""><c path="flash.media.AVResult"/></f></seekToLivePoint>
		<seek public="1" set="method"><f a="offset:?inBufferSeek">
	<x path="Float"/>
	<x path="Bool"/>
	<c path="flash.media.AVResult"/>
</f></seek>
		<resume public="1" set="method"><f a=""><x path="Bool"/></f></resume>
		<play public="1" set="method"><f a=""><c path="flash.media.AVResult"/></f></play>
		<pause public="1" set="method"><f a=""><c path="flash.media.AVResult"/></f></pause>
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<volume public="1"><x path="Float"/></volume>
		<useHardwareDecoder public="1"><x path="Bool"/></useHardwareDecoder>
		<time public="1" set="null"><x path="Float"/></time>
		<renderType public="1" set="null"><c path="String"/></renderType>
		<playState public="1" set="null"><c path="flash.media.AVPlayState"/></playState>
		<initialBufferTime public="1" get="null"><x path="Float"/></initialBufferTime>
		<frameTime public="1" set="null"><x path="Float"/></frameTime>
		<droppedFrames public="1" set="null"><x path="Int"/></droppedFrames>
		<decoderType public="1" set="null"><c path="String"/></decoderType>
		<currentFPS public="1" set="null"><x path="Float"/></currentFPS>
		<captionsEnabled public="1"><x path="Bool"/></captionsEnabled>
		<captionStyle public="1" get="null"><c path="flash.media.AVCaptionStyle"/></captionStyle>
		<bufferTime public="1" get="null"><x path="Float"/></bufferTime>
		<bufferLength public="1" set="null"><x path="Float"/></bufferLength>
		<backBufferTime public="1" get="null"><x path="Float"/></backBufferTime>
		<backBufferLength public="1" set="null"><x path="Float"/></backBufferLength>
		<new public="1" set="method"><f a="source">
	<c path="flash.media.AVSource"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.media.Camera" params="" file="/usr/lib/haxe/std/flash/media/Camera.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<isSupported public="1" set="null" static="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</isSupported>
		<names public="1" set="null" static="1"><c path="Array"><d/></c></names>
		<_scanHardware public="1" set="method" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</_scanHardware>
		<getCamera public="1" set="method" static="1"><f a="?name">
	<c path="String"/>
	<c path="flash.media.Camera"/>
</f></getCamera>
		<setQuality public="1" set="method"><f a="bandwidth:quality">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setQuality>
		<setMotionLevel public="1" set="method"><f a="motionLevel:?timeout">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setMotionLevel>
		<setMode public="1" set="method"><f a="width:height:fps:?favorArea">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setMode>
		<setLoopback public="1" set="method"><f a="?compress">
	<x path="Bool"/>
	<x path="Void"/>
</f></setLoopback>
		<setKeyFrameInterval public="1" set="method"><f a="keyFrameInterval">
	<x path="Int"/>
	<x path="Void"/>
</f></setKeyFrameInterval>
		<setCursor public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Void"/>
</f></setCursor>
		<width public="1" set="null"><x path="Int"/></width>
		<quality public="1" set="null"><x path="Int"/></quality>
		<name public="1" set="null"><c path="String"/></name>
		<muted public="1" set="null"><x path="Bool"/></muted>
		<motionTimeout public="1" set="null"><x path="Int"/></motionTimeout>
		<motionLevel public="1" set="null"><x path="Int"/></motionLevel>
		<loopback public="1" set="null"><x path="Bool"/></loopback>
		<keyFrameInterval public="1" set="null"><x path="Int"/></keyFrameInterval>
		<index public="1" set="null"><x path="Int"/></index>
		<height public="1" set="null"><x path="Int"/></height>
		<fps public="1" set="null"><x path="Float"/></fps>
		<currentFPS public="1" set="null"><x path="Float"/></currentFPS>
		<bandwidth public="1" set="null"><x path="Int"/></bandwidth>
		<activityLevel public="1" set="null"><x path="Float"/></activityLevel>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.media.Microphone" params="" file="/usr/lib/haxe/std/flash/media/Microphone.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<isSupported public="1" set="null" static="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</isSupported>
		<names public="1" set="null" static="1"><c path="Array"><d/></c></names>
		<getEnhancedMicrophone public="1" set="method" static="1">
			<f a="?index">
				<x path="Int"/>
				<c path="flash.media.Microphone"/>
			</f>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</getEnhancedMicrophone>
		<getMicrophone public="1" set="method" static="1"><f a="?index">
	<x path="Int"/>
	<c path="flash.media.Microphone"/>
</f></getMicrophone>
		<setUseEchoSuppression public="1" set="method"><f a="useEchoSuppression">
	<x path="Bool"/>
	<x path="Void"/>
</f></setUseEchoSuppression>
		<setSilenceLevel public="1" set="method"><f a="silenceLevel:?timeout">
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setSilenceLevel>
		<setLoopBack public="1" set="method"><f a="?state">
	<x path="Bool"/>
	<x path="Void"/>
</f></setLoopBack>
		<useEchoSuppression public="1" set="null"><x path="Bool"/></useEchoSuppression>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<silenceTimeout public="1" set="null"><x path="Int"/></silenceTimeout>
		<silenceLevel public="1" set="null"><x path="Float"/></silenceLevel>
		<rate public="1"><x path="Int"/></rate>
		<noiseSuppressionLevel public="1">
			<x path="Int"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</noiseSuppressionLevel>
		<name public="1" set="null"><c path="String"/></name>
		<muted public="1" set="null"><x path="Bool"/></muted>
		<index public="1" set="null"><x path="Int"/></index>
		<gain public="1"><x path="Float"/></gain>
		<framesPerPacket public="1">
			<x path="Int"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</framesPerPacket>
		<enhancedOptions public="1">
			<c path="flash.media.MicrophoneEnhancedOptions"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</enhancedOptions>
		<encodeQuality public="1">
			<x path="Int"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</encodeQuality>
		<enableVAD public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</enableVAD>
		<codec public="1">
			<e path="flash.media.SoundCodec"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</codec>
		<activityLevel public="1" set="null"><x path="Float"/></activityLevel>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.media.MicrophoneEnhancedMode" params="" file="/usr/lib/haxe/std/flash/media/MicrophoneEnhancedMode.hx">
		<SPEAKER_MUTE/>
		<OFF/>
		<HEADSET/>
		<HALF_DUPLEX/>
		<FULL_DUPLEX/>
		<meta>
			<m n=":fakeEnum"><e>String</e></m>
			<m n=":require"><e>flash10_2</e></m>
		</meta>
	</enum>
	<class path="flash.media.MicrophoneEnhancedOptions" params="" file="/usr/lib/haxe/std/flash/media/MicrophoneEnhancedOptions.hx" extern="1">
		<nonLinearProcessing public="1"><x path="Bool"/></nonLinearProcessing>
		<mode public="1"><e path="flash.media.MicrophoneEnhancedMode"/></mode>
		<isVoiceDetected public="1"><x path="Int"/></isVoiceDetected>
		<echoPath public="1"><x path="Int"/></echoPath>
		<autoGain public="1"><x path="Bool"/></autoGain>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":final"/>
			<m n=":require"><e>flash10_2</e></m>
		</meta>
	</class>
	<enum path="flash.media.SoundCodec" params="" file="/usr/lib/haxe/std/flash/media/SoundCodec.hx">
		<SPEEX/>
		<PCMU/>
		<PCMA/>
		<NELLYMOSER/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.media.SoundTransform" params="" file="/usr/lib/haxe/std/flash/media/SoundTransform.hx" extern="1">
		<volume public="1"><x path="Float"/></volume>
		<rightToRight public="1"><x path="Float"/></rightToRight>
		<rightToLeft public="1"><x path="Float"/></rightToLeft>
		<pan public="1"><x path="Float"/></pan>
		<leftToRight public="1"><x path="Float"/></leftToRight>
		<leftToLeft public="1"><x path="Float"/></leftToLeft>
		<new public="1" set="method"><f a="?vol:?panning">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.media.StageVideo" params="" file="/usr/lib/haxe/std/flash/media/StageVideo.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<attachNetStream public="1" set="method"><f a="netStream">
	<c path="flash.net.NetStream"/>
	<x path="Void"/>
</f></attachNetStream>
		<zoom public="1"><c path="flash.geom.Point"/></zoom>
		<viewPort public="1"><c path="flash.geom.Rectangle"/></viewPort>
		<videoWidth public="1" set="null"><x path="Int"/></videoWidth>
		<videoHeight public="1" set="null"><x path="Int"/></videoHeight>
		<pan public="1"><c path="flash.geom.Point"/></pan>
		<depth public="1"><x path="Int"/></depth>
		<colorSpaces public="1" set="null"><c path="flash.Vector"><c path="String"/></c></colorSpaces>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":require"><e>flash10_2</e></m></meta>
	</class>
	<class path="flash.media.VideoStreamSettings" params="" file="/usr/lib/haxe/std/flash/media/VideoStreamSettings.hx" extern="1">
		<setQuality public="1" set="method"><f a="bandwidth:quality">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setQuality>
		<setMode public="1" set="method"><f a="width:height:fps">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setMode>
		<setKeyFrameInterval public="1" set="method"><f a="keyFrameInterval">
	<x path="Int"/>
	<x path="Void"/>
</f></setKeyFrameInterval>
		<width public="1" set="null"><x path="Int"/></width>
		<quality public="1" set="null"><x path="Int"/></quality>
		<keyFrameInterval public="1" set="null"><x path="Int"/></keyFrameInterval>
		<height public="1" set="null"><x path="Int"/></height>
		<fps public="1" set="null"><x path="Float"/></fps>
		<codec public="1" set="null"><c path="String"/></codec>
		<bandwidth public="1" set="null"><x path="Int"/></bandwidth>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.net.NetConnection" params="" file="/usr/lib/haxe/std/flash/net/NetConnection.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<defaultObjectEncoding public="1" static="1"><x path="UInt"/></defaultObjectEncoding>
		<connect public="1" set="method"><f a="command:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<x path="Void"/>
</f></connect>
		<close public="1" set="method"><f a=""><x path="Void"/></f></close>
		<call public="1" set="method"><f a="command:responder:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<c path="flash.net.Responder"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<x path="Void"/>
</f></call>
		<addHeader public="1" set="method"><f a="operation:?mustUnderstand:?param">
	<c path="String"/>
	<x path="Bool"/>
	<t path="flash.utils.Object"/>
	<x path="Void"/>
</f></addHeader>
		<usingTLS public="1" set="null"><x path="Bool"/></usingTLS>
		<uri public="1" set="null"><c path="String"/></uri>
		<unconnectedPeerStreams public="1" set="null">
			<c path="Array"><d/></c>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</unconnectedPeerStreams>
		<proxyType public="1"><c path="String"/></proxyType>
		<protocol public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</protocol>
		<objectEncoding public="1"><x path="UInt"/></objectEncoding>
		<nearNonce public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</nearNonce>
		<nearID public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</nearID>
		<maxPeerConnections public="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</maxPeerConnections>
		<farNonce public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</farNonce>
		<farID public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</farID>
		<connectedProxyType public="1" set="null"><c path="String"/></connectedProxyType>
		<connected public="1" set="null"><x path="Bool"/></connected>
		<client public="1"><d/></client>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.net.NetStream" params="" file="/usr/lib/haxe/std/flash/net/NetStream.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<CONNECT_TO_FMS public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</CONNECT_TO_FMS>
		<DIRECT_CONNECTIONS public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</DIRECT_CONNECTIONS>
		<togglePause public="1" set="method"><f a=""><x path="Void"/></f></togglePause>
		<step public="1" set="method">
			<f a="frames">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</step>
		<send public="1" set="method"><f a="handlerName:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<x path="Void"/>
</f></send>
		<seek public="1" set="method"><f a="offset">
	<x path="Float"/>
	<x path="Void"/>
</f></seek>
		<resume public="1" set="method"><f a=""><x path="Void"/></f></resume>
		<receiveVideoFPS public="1" set="method"><f a="FPS">
	<x path="Float"/>
	<x path="Void"/>
</f></receiveVideoFPS>
		<receiveVideo public="1" set="method"><f a="flag">
	<x path="Bool"/>
	<x path="Void"/>
</f></receiveVideo>
		<receiveAudio public="1" set="method"><f a="flag">
	<x path="Bool"/>
	<x path="Void"/>
</f></receiveAudio>
		<publish public="1" set="method"><f a="?name:?type">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></publish>
		<play2 public="1" set="method">
			<f a="param">
				<c path="flash.net.NetStreamPlayOptions"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</play2>
		<play public="1" set="method"><f a="?p1:?p2:?p3:?p4:?p5">
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<x path="Void"/>
</f></play>
		<pause public="1" set="method"><f a=""><x path="Void"/></f></pause>
		<onPeerConnect public="1" set="method">
			<f a="subscriber">
				<c path="flash.net.NetStream"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</onPeerConnect>
		<close public="1" set="method"><f a=""><x path="Void"/></f></close>
		<attachCamera public="1" set="method"><f a="theCamera:?snapshotMilliseconds">
	<c path="flash.media.Camera"/>
	<x path="Int"/>
	<x path="Void"/>
</f></attachCamera>
		<attachAudio public="1" set="method"><f a="microphone">
	<c path="flash.media.Microphone"/>
	<x path="Void"/>
</f></attachAudio>
		<attach public="1" set="method">
			<f a="connection">
				<c path="flash.net.NetConnection"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</attach>
		<appendBytesAction public="1" set="method">
			<f a="netStreamAppendBytesAction">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</appendBytesAction>
		<appendBytes public="1" set="method">
			<f a="bytes">
				<c path="flash.utils.ByteArray"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</appendBytes>
		<videoStreamSettings public="1">
			<c path="flash.media.VideoStreamSettings"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</videoStreamSettings>
		<videoSampleAccess public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</videoSampleAccess>
		<videoReliable public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</videoReliable>
		<videoCodec public="1" set="null"><x path="UInt"/></videoCodec>
		<useHardwareDecoder public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</useHardwareDecoder>
		<time public="1" set="null"><x path="Float"/></time>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<peerStreams public="1" set="null">
			<c path="Array"><d/></c>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</peerStreams>
		<objectEncoding public="1" set="null"><x path="UInt"/></objectEncoding>
		<nearNonce public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</nearNonce>
		<multicastWindowDuration public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastWindowDuration>
		<multicastRelayMarginDuration public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastRelayMarginDuration>
		<multicastPushNeighborLimit public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastPushNeighborLimit>
		<multicastInfo public="1" set="null">
			<c path="flash.net.NetStreamMulticastInfo"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastInfo>
		<multicastFetchPeriod public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastFetchPeriod>
		<multicastAvailabilityUpdatePeriod public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastAvailabilityUpdatePeriod>
		<multicastAvailabilitySendToAll public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastAvailabilitySendToAll>
		<maxPauseBufferTime public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</maxPauseBufferTime>
		<liveDelay public="1" set="null"><x path="Float"/></liveDelay>
		<info public="1" set="null">
			<c path="flash.net.NetStreamInfo"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</info>
		<inBufferSeek public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</inBufferSeek>
		<farNonce public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</farNonce>
		<farID public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</farID>
		<decodedFrames public="1" set="null"><x path="UInt"/></decodedFrames>
		<dataReliable public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</dataReliable>
		<currentFPS public="1" set="null"><x path="Float"/></currentFPS>
		<client public="1"><d/></client>
		<checkPolicyFile public="1"><x path="Bool"/></checkPolicyFile>
		<bytesTotal public="1" set="null"><x path="UInt"/></bytesTotal>
		<bytesLoaded public="1" set="null"><x path="UInt"/></bytesLoaded>
		<bufferTimeMax public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</bufferTimeMax>
		<bufferTime public="1"><x path="Float"/></bufferTime>
		<bufferLength public="1" set="null"><x path="Float"/></bufferLength>
		<backBufferTime public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</backBufferTime>
		<backBufferLength public="1" set="null">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</backBufferLength>
		<audioSampleAccess public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</audioSampleAccess>
		<audioReliable public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</audioReliable>
		<audioCodec public="1" set="null"><x path="UInt"/></audioCodec>
		<new public="1" set="method"><f a="connection:?peerID">
	<c path="flash.net.NetConnection"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.net.NetStreamInfo" params="" file="/usr/lib/haxe/std/flash/net/NetStreamInfo.hx" extern="1">
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<xmpData public="1" set="null"><d/></xmpData>
		<videoLossRate public="1" set="null">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</videoLossRate>
		<videoBytesPerSecond public="1" set="null"><x path="Float"/></videoBytesPerSecond>
		<videoByteCount public="1" set="null"><x path="Float"/></videoByteCount>
		<videoBufferLength public="1" set="null"><x path="Float"/></videoBufferLength>
		<videoBufferByteLength public="1" set="null"><x path="Float"/></videoBufferByteLength>
		<uri public="1" set="null"><c path="String"/></uri>
		<resourceName public="1" set="null"><c path="String"/></resourceName>
		<playbackBytesPerSecond public="1" set="null"><x path="Float"/></playbackBytesPerSecond>
		<metaData public="1" set="null"><d/></metaData>
		<maxBytesPerSecond public="1" set="null"><x path="Float"/></maxBytesPerSecond>
		<isLive public="1" set="null"><x path="Bool"/></isLive>
		<droppedFrames public="1" set="null"><x path="Float"/></droppedFrames>
		<dataBytesPerSecond public="1" set="null"><x path="Float"/></dataBytesPerSecond>
		<dataByteCount public="1" set="null"><x path="Float"/></dataByteCount>
		<dataBufferLength public="1" set="null"><x path="Float"/></dataBufferLength>
		<dataBufferByteLength public="1" set="null"><x path="Float"/></dataBufferByteLength>
		<currentBytesPerSecond public="1" set="null"><x path="Float"/></currentBytesPerSecond>
		<byteCount public="1" set="null"><x path="Float"/></byteCount>
		<audioLossRate public="1" set="null"><x path="Float"/></audioLossRate>
		<audioBytesPerSecond public="1" set="null"><x path="Float"/></audioBytesPerSecond>
		<audioByteCount public="1" set="null"><x path="Float"/></audioByteCount>
		<audioBufferLength public="1" set="null"><x path="Float"/></audioBufferLength>
		<audioBufferByteLength public="1" set="null"><x path="Float"/></audioBufferByteLength>
		<SRTT public="1" set="null"><x path="Float"/></SRTT>
		<new public="1" set="method"><f a="curBPS:byteCount:maxBPS:audioBPS:audioByteCount:videoBPS:videoByteCount:dataBPS:dataByteCount:playbackBPS:droppedFrames:audioBufferByteLength:videoBufferByteLength:dataBufferByteLength:audioBufferLength:videoBufferLength:dataBufferLength:srtt:audioLossRate:videoLossRate:?metaData:?xmpData:?uri:?resourceName:?isLive">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<d/>
	<d/>
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.net.NetStreamMulticastInfo" params="" file="/usr/lib/haxe/std/flash/net/NetStreamMulticastInfo.hx" extern="1">
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<sendDataBytesPerSecond public="1" set="null"><x path="Float"/></sendDataBytesPerSecond>
		<sendControlBytesPerSecondToServer public="1" set="null"><x path="Float"/></sendControlBytesPerSecondToServer>
		<sendControlBytesPerSecond public="1" set="null"><x path="Float"/></sendControlBytesPerSecond>
		<receiveDataBytesPerSecondFromServer public="1" set="null"><x path="Float"/></receiveDataBytesPerSecondFromServer>
		<receiveDataBytesPerSecondFromIPMulticast public="1" set="null"><x path="Float"/></receiveDataBytesPerSecondFromIPMulticast>
		<receiveDataBytesPerSecond public="1" set="null"><x path="Float"/></receiveDataBytesPerSecond>
		<receiveControlBytesPerSecond public="1" set="null"><x path="Float"/></receiveControlBytesPerSecond>
		<fragmentsRequestedFromPeers public="1" set="null"><x path="Float"/></fragmentsRequestedFromPeers>
		<fragmentsRequestedByPeers public="1" set="null"><x path="Float"/></fragmentsRequestedByPeers>
		<fragmentsReceivedFromServer public="1" set="null"><x path="Float"/></fragmentsReceivedFromServer>
		<fragmentsReceivedFromIPMulticast public="1" set="null"><x path="Float"/></fragmentsReceivedFromIPMulticast>
		<fragmentsPushedToPeers public="1" set="null"><x path="Float"/></fragmentsPushedToPeers>
		<fragmentsPushedFromPeers public="1" set="null"><x path="Float"/></fragmentsPushedFromPeers>
		<bytesRequestedFromPeers public="1" set="null"><x path="Float"/></bytesRequestedFromPeers>
		<bytesRequestedByPeers public="1" set="null"><x path="Float"/></bytesRequestedByPeers>
		<bytesReceivedFromServer public="1" set="null"><x path="Float"/></bytesReceivedFromServer>
		<bytesReceivedFromIPMulticast public="1" set="null"><x path="Float"/></bytesReceivedFromIPMulticast>
		<bytesPushedToPeers public="1" set="null"><x path="Float"/></bytesPushedToPeers>
		<bytesPushedFromPeers public="1" set="null"><x path="Float"/></bytesPushedFromPeers>
		<new public="1" set="method"><f a="sendDataBytesPerSecond:sendControlBytesPerSecond:receiveDataBytesPerSecond:receiveControlBytesPerSecond:bytesPushedToPeers:fragmentsPushedToPeers:bytesRequestedByPeers:fragmentsRequestedByPeers:bytesPushedFromPeers:fragmentsPushedFromPeers:bytesRequestedFromPeers:fragmentsRequestedFromPeers:sendControlBytesPerSecondToServer:receiveDataBytesPerSecondFromServer:bytesReceivedFromServer:fragmentsReceivedFromServer:receiveDataBytesPerSecondFromIPMulticast:bytesReceivedFromIPMulticast:fragmentsReceivedFromIPMulticast">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":final"/>
			<m n=":require"><e>flash10_1</e></m>
		</meta>
	</class>
	<class path="flash.net.NetStreamPlayOptions" params="" file="/usr/lib/haxe/std/flash/net/NetStreamPlayOptions.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<transition public="1"><c path="String"/></transition>
		<streamName public="1"><c path="String"/></streamName>
		<start public="1"><x path="Float"/></start>
		<oldStreamName public="1"><c path="String"/></oldStreamName>
		<offset public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</offset>
		<len public="1"><x path="Float"/></len>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.net.Responder" params="" file="/usr/lib/haxe/std/flash/net/Responder.hx" extern="1"><new public="1" set="method"><f a="result:?status">
	<d/>
	<d/>
	<x path="Void"/>
</f></new></class>
	<class path="flash.net.URLRequest" params="" file="/usr/lib/haxe/std/flash/net/URLRequest.hx" extern="1">
		<url public="1"><c path="String"/></url>
		<requestHeaders public="1"><c path="Array"><c path="flash.net.URLRequestHeader"/></c></requestHeaders>
		<method public="1"><c path="String"/></method>
		<digest public="1"><c path="String"/></digest>
		<data public="1"><d/></data>
		<contentType public="1"><c path="String"/></contentType>
		<new public="1" set="method"><f a="?url">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.net.URLRequestHeader" params="" file="/usr/lib/haxe/std/flash/net/URLRequestHeader.hx" extern="1">
		<value public="1"><c path="String"/></value>
		<name public="1"><c path="String"/></name>
		<new public="1" set="method"><f a="?name:?value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.system.ApplicationDomain" params="" file="/usr/lib/haxe/std/flash/system/ApplicationDomain.hx" extern="1">
		<MIN_DOMAIN_MEMORY_LENGTH public="1" set="null" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</MIN_DOMAIN_MEMORY_LENGTH>
		<currentDomain public="1" set="null" static="1"><c path="flash.system.ApplicationDomain"/></currentDomain>
		<hasDefinition public="1" set="method"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></hasDefinition>
		<getDefinition public="1" set="method"><f a="name">
	<c path="String"/>
	<t path="flash.utils.Object"/>
</f></getDefinition>
		<parentDomain public="1" set="null"><c path="flash.system.ApplicationDomain"/></parentDomain>
		<domainMemory public="1">
			<c path="flash.utils.ByteArray"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</domainMemory>
		<new public="1" set="method"><f a="?parentDomain">
	<c path="flash.system.ApplicationDomain"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.system.ImageDecodingPolicy" params="" file="/usr/lib/haxe/std/flash/system/ImageDecodingPolicy.hx">
		<ON_LOAD/>
		<ON_DEMAND/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.system.LoaderContext" params="" file="/usr/lib/haxe/std/flash/system/LoaderContext.hx" extern="1">
		<securityDomain public="1"><c path="flash.system.SecurityDomain"/></securityDomain>
		<requestedContentParent public="1">
			<c path="flash.display.DisplayObjectContainer"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</requestedContentParent>
		<parameters public="1">
			<d/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</parameters>
		<imageDecodingPolicy public="1">
			<e path="flash.system.ImageDecodingPolicy"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</imageDecodingPolicy>
		<checkPolicyFile public="1"><x path="Bool"/></checkPolicyFile>
		<applicationDomain public="1"><c path="flash.system.ApplicationDomain"/></applicationDomain>
		<allowLoadBytesCodeExecution public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</allowLoadBytesCodeExecution>
		<allowCodeImport public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</allowCodeImport>
		<new public="1" set="method"><f a="?checkPolicyFile:?applicationDomain:?securityDomain">
	<x path="Bool"/>
	<c path="flash.system.ApplicationDomain"/>
	<c path="flash.system.SecurityDomain"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.system.SecurityDomain" params="" file="/usr/lib/haxe/std/flash/system/SecurityDomain.hx" extern="1"><currentDomain public="1" set="null" static="1"><c path="flash.system.SecurityDomain"/></currentDomain></class>
	<enum path="flash.text.AntiAliasType" params="" file="/usr/lib/haxe/std/flash/text/AntiAliasType.hx">
		<NORMAL/>
		<ADVANCED/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.text.GridFitType" params="" file="/usr/lib/haxe/std/flash/text/GridFitType.hx">
		<SUBPIXEL/>
		<PIXEL/>
		<NONE/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.text.StyleSheet" params="" file="/usr/lib/haxe/std/flash/text/StyleSheet.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<transform public="1" set="method"><f a="formatObject">
	<t path="flash.utils.Object"/>
	<c path="flash.text.TextFormat"/>
</f></transform>
		<setStyle public="1" set="method"><f a="styleName:styleObject">
	<c path="String"/>
	<t path="flash.utils.Object"/>
	<x path="Void"/>
</f></setStyle>
		<parseCSS public="1" set="method"><f a="CSSText">
	<c path="String"/>
	<x path="Void"/>
</f></parseCSS>
		<getStyle public="1" set="method"><f a="styleName">
	<c path="String"/>
	<t path="flash.utils.Object"/>
</f></getStyle>
		<clear public="1" set="method"><f a=""><x path="Void"/></f></clear>
		<styleNames public="1" set="null"><c path="Array"><d/></c></styleNames>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.text.TextField" params="" file="/usr/lib/haxe/std/flash/text/TextField.hx" extern="1">
		<extends path="flash.display.InteractiveObject"/>
		<isFontCompatible public="1" set="method" static="1">
			<f a="fontName:fontStyle">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</isFontCompatible>
		<setTextFormat public="1" set="method"><f a="format:?beginIndex:?endIndex">
	<c path="flash.text.TextFormat"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setTextFormat>
		<setSelection public="1" set="method"><f a="beginIndex:endIndex">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setSelection>
		<replaceText public="1" set="method"><f a="beginIndex:endIndex:newText">
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></replaceText>
		<replaceSelectedText public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></replaceSelectedText>
		<pasteRichText public="1" set="method"><f a="richText">
	<c path="String"/>
	<x path="Bool"/>
</f></pasteRichText>
		<insertXMLText public="1" set="method"><f a="beginIndex:endIndex:richText:?pasting">
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></insertXMLText>
		<getXMLText public="1" set="method"><f a="?beginIndex:?endIndex">
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
</f></getXMLText>
		<getTextRuns public="1" set="method"><f a="?beginIndex:?endIndex">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><d/></c>
</f></getTextRuns>
		<getTextFormat public="1" set="method"><f a="?beginIndex:?endIndex">
	<x path="Int"/>
	<x path="Int"/>
	<c path="flash.text.TextFormat"/>
</f></getTextFormat>
		<getRawText public="1" set="method"><f a=""><c path="String"/></f></getRawText>
		<getParagraphLength public="1" set="method"><f a="charIndex">
	<x path="Int"/>
	<x path="Int"/>
</f></getParagraphLength>
		<getLineText public="1" set="method"><f a="lineIndex">
	<x path="Int"/>
	<c path="String"/>
</f></getLineText>
		<getLineOffset public="1" set="method"><f a="lineIndex">
	<x path="Int"/>
	<x path="Int"/>
</f></getLineOffset>
		<getLineMetrics public="1" set="method"><f a="lineIndex">
	<x path="Int"/>
	<c path="flash.text.TextLineMetrics"/>
</f></getLineMetrics>
		<getLineLength public="1" set="method"><f a="lineIndex">
	<x path="Int"/>
	<x path="Int"/>
</f></getLineLength>
		<getLineIndexOfChar public="1" set="method"><f a="charIndex">
	<x path="Int"/>
	<x path="Int"/>
</f></getLineIndexOfChar>
		<getLineIndexAtPoint public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></getLineIndexAtPoint>
		<getImageReference public="1" set="method"><f a="id">
	<c path="String"/>
	<c path="flash.display.DisplayObject"/>
</f></getImageReference>
		<getFirstCharInParagraph public="1" set="method"><f a="charIndex">
	<x path="Int"/>
	<x path="Int"/>
</f></getFirstCharInParagraph>
		<getCharIndexAtPoint public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></getCharIndexAtPoint>
		<getCharBoundaries public="1" set="method"><f a="charIndex">
	<x path="Int"/>
	<c path="flash.geom.Rectangle"/>
</f></getCharBoundaries>
		<copyRichText public="1" set="method"><f a=""><c path="String"/></f></copyRichText>
		<appendText public="1" set="method"><f a="newText">
	<c path="String"/>
	<x path="Void"/>
</f></appendText>
		<wordWrap public="1"><x path="Bool"/></wordWrap>
		<useRichTextClipboard public="1"><x path="Bool"/></useRichTextClipboard>
		<type public="1"><e path="flash.text.TextFieldType"/></type>
		<thickness public="1"><x path="Float"/></thickness>
		<textWidth public="1" set="null"><x path="Float"/></textWidth>
		<textInteractionMode public="1" set="null">
			<e path="flash.text.TextInteractionMode"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</textInteractionMode>
		<textHeight public="1" set="null"><x path="Float"/></textHeight>
		<textColor public="1"><x path="UInt"/></textColor>
		<text public="1"><c path="String"/></text>
		<styleSheet public="1"><c path="flash.text.StyleSheet"/></styleSheet>
		<sharpness public="1"><x path="Float"/></sharpness>
		<selectionEndIndex public="1" set="null"><x path="Int"/></selectionEndIndex>
		<selectionBeginIndex public="1" set="null"><x path="Int"/></selectionBeginIndex>
		<selectedText public="1" set="null"><c path="String"/></selectedText>
		<selectable public="1"><x path="Bool"/></selectable>
		<scrollV public="1"><x path="Int"/></scrollV>
		<scrollH public="1"><x path="Int"/></scrollH>
		<restrict public="1"><c path="String"/></restrict>
		<numLines public="1" set="null"><x path="Int"/></numLines>
		<multiline public="1"><x path="Bool"/></multiline>
		<mouseWheelEnabled public="1"><x path="Bool"/></mouseWheelEnabled>
		<maxScrollV public="1" set="null"><x path="Int"/></maxScrollV>
		<maxScrollH public="1" set="null"><x path="Int"/></maxScrollH>
		<maxChars public="1"><x path="Int"/></maxChars>
		<length public="1" set="null"><x path="Int"/></length>
		<htmlText public="1"><c path="String"/></htmlText>
		<gridFitType public="1"><e path="flash.text.GridFitType"/></gridFitType>
		<embedFonts public="1"><x path="Bool"/></embedFonts>
		<displayAsPassword public="1"><x path="Bool"/></displayAsPassword>
		<defaultTextFormat public="1"><c path="flash.text.TextFormat"/></defaultTextFormat>
		<condenseWhite public="1"><x path="Bool"/></condenseWhite>
		<caretIndex public="1" set="null"><x path="Int"/></caretIndex>
		<bottomScrollV public="1" set="null"><x path="Int"/></bottomScrollV>
		<borderColor public="1"><x path="UInt"/></borderColor>
		<border public="1"><x path="Bool"/></border>
		<backgroundColor public="1"><x path="UInt"/></backgroundColor>
		<background public="1"><x path="Bool"/></background>
		<autoSize public="1"><e path="flash.text.TextFieldAutoSize"/></autoSize>
		<antiAliasType public="1"><e path="flash.text.AntiAliasType"/></antiAliasType>
		<alwaysShowSelection public="1"><x path="Bool"/></alwaysShowSelection>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<enum path="flash.text.TextFieldAutoSize" params="" file="/usr/lib/haxe/std/flash/text/TextFieldAutoSize.hx">
		<RIGHT/>
		<NONE/>
		<LEFT/>
		<CENTER/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.text.TextFieldType" params="" file="/usr/lib/haxe/std/flash/text/TextFieldType.hx">
		<INPUT/>
		<DYNAMIC/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.text.TextFormat" params="" file="/usr/lib/haxe/std/flash/text/TextFormat.hx" extern="1">
		<url public="1"><c path="String"/></url>
		<underline public="1"><t path="Null"><x path="Bool"/></t></underline>
		<target public="1"><c path="String"/></target>
		<tabStops public="1"><c path="Array"><x path="UInt"/></c></tabStops>
		<size public="1"><t path="Null"><x path="Float"/></t></size>
		<rightMargin public="1"><t path="Null"><x path="Float"/></t></rightMargin>
		<letterSpacing public="1"><t path="Null"><x path="Float"/></t></letterSpacing>
		<leftMargin public="1"><t path="Null"><x path="Float"/></t></leftMargin>
		<leading public="1"><t path="Null"><x path="Float"/></t></leading>
		<kerning public="1"><t path="Null"><x path="Bool"/></t></kerning>
		<italic public="1"><t path="Null"><x path="Bool"/></t></italic>
		<indent public="1"><t path="Null"><x path="Float"/></t></indent>
		<font public="1"><c path="String"/></font>
		<display public="1"><e path="flash.text.TextFormatDisplay"/></display>
		<color public="1"><t path="Null"><x path="UInt"/></t></color>
		<bullet public="1"><t path="Null"><x path="Bool"/></t></bullet>
		<bold public="1"><t path="Null"><x path="Bool"/></t></bold>
		<blockIndent public="1"><t path="Null"><x path="Float"/></t></blockIndent>
		<align public="1"><e path="flash.text.TextFormatAlign"/></align>
		<new public="1" set="method"><f a="?font:?size:?color:?bold:?italic:?underline:?url:?target:?align:?leftMargin:?rightMargin:?indent:?leading">
	<c path="String"/>
	<x path="Float"/>
	<x path="UInt"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="String"/>
	<c path="String"/>
	<e path="flash.text.TextFormatAlign"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="flash.text.TextFormatAlign" params="" file="/usr/lib/haxe/std/flash/text/TextFormatAlign.hx">
		<START/>
		<RIGHT/>
		<LEFT/>
		<JUSTIFY/>
		<END/>
		<CENTER/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.text.TextFormatDisplay" params="" file="/usr/lib/haxe/std/flash/text/TextFormatDisplay.hx">
		<INLINE/>
		<BLOCK/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.text.TextInteractionMode" params="" file="/usr/lib/haxe/std/flash/text/TextInteractionMode.hx">
		<SELECTION/>
		<NORMAL/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.text.TextLineMetrics" params="" file="/usr/lib/haxe/std/flash/text/TextLineMetrics.hx" extern="1">
		<x public="1"><x path="Float"/></x>
		<width public="1"><x path="Float"/></width>
		<leading public="1"><x path="Float"/></leading>
		<height public="1"><x path="Float"/></height>
		<descent public="1"><x path="Float"/></descent>
		<ascent public="1"><x path="Float"/></ascent>
		<new public="1" set="method"><f a="x:width:height:ascent:descent:leading">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.text.TextSnapshot" params="" file="/usr/lib/haxe/std/flash/text/TextSnapshot.hx" extern="1">
		<setSelected public="1" set="method"><f a="beginIndex:endIndex:select">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setSelected>
		<setSelectColor public="1" set="method"><f a="?hexColor">
	<x path="UInt"/>
	<x path="Void"/>
</f></setSelectColor>
		<hitTestTextNearPos public="1" set="method"><f a="x:y:?maxDistance">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></hitTestTextNearPos>
		<getTextRunInfo public="1" set="method"><f a="beginIndex:endIndex">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><d/></c>
</f></getTextRunInfo>
		<getText public="1" set="method"><f a="beginIndex:endIndex:?includeLineEndings">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<c path="String"/>
</f></getText>
		<getSelectedText public="1" set="method"><f a="?includeLineEndings">
	<x path="Bool"/>
	<c path="String"/>
</f></getSelectedText>
		<getSelected public="1" set="method"><f a="beginIndex:endIndex">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></getSelected>
		<findText public="1" set="method"><f a="beginIndex:textToFind:caseSensitive">
	<x path="Int"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></findText>
		<charCount public="1" set="null"><x path="Int"/></charCount>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.ui.ContextMenu" params="" file="/usr/lib/haxe/std/flash/ui/ContextMenu.hx" extern="1">
		<extends path="flash.display.NativeMenu"/>
		<isSupported public="1" set="null" static="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</isSupported>
		<hideBuiltInItems public="1" set="method"><f a=""><x path="Void"/></f></hideBuiltInItems>
		<clone public="1" set="method"><f a=""><c path="flash.ui.ContextMenu"/></f></clone>
		<link public="1">
			<c path="flash.net.URLRequest"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</link>
		<customItems public="1"><c path="Array"><d/></c></customItems>
		<clipboardMenu public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</clipboardMenu>
		<clipboardItems public="1">
			<c path="flash.ui.ContextMenuClipboardItems"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</clipboardItems>
		<builtInItems public="1"><c path="flash.ui.ContextMenuBuiltInItems"/></builtInItems>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.ui.ContextMenuBuiltInItems" params="" file="/usr/lib/haxe/std/flash/ui/ContextMenuBuiltInItems.hx" extern="1">
		<clone public="1" set="method"><f a=""><c path="flash.ui.ContextMenuBuiltInItems"/></f></clone>
		<zoom public="1"><x path="Bool"/></zoom>
		<save public="1"><x path="Bool"/></save>
		<rewind public="1"><x path="Bool"/></rewind>
		<quality public="1"><x path="Bool"/></quality>
		<print public="1"><x path="Bool"/></print>
		<play public="1"><x path="Bool"/></play>
		<loop public="1"><x path="Bool"/></loop>
		<forwardAndBack public="1"><x path="Bool"/></forwardAndBack>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.ui.ContextMenuClipboardItems" params="" file="/usr/lib/haxe/std/flash/ui/ContextMenuClipboardItems.hx" extern="1">
		<clone public="1" set="method"><f a=""><c path="flash.ui.ContextMenuClipboardItems"/></f></clone>
		<selectAll public="1"><x path="Bool"/></selectAll>
		<paste public="1"><x path="Bool"/></paste>
		<cut public="1"><x path="Bool"/></cut>
		<copy public="1"><x path="Bool"/></copy>
		<clear public="1"><x path="Bool"/></clear>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.utils.IDataInput" params="" file="/usr/lib/haxe/std/flash/utils/IDataInput.hx" extern="1" interface="1">
		<readUnsignedShort public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedShort>
		<readUnsignedInt public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedInt>
		<readUnsignedByte public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedByte>
		<readUTFBytes public="1" set="method"><f a="length">
	<x path="UInt"/>
	<c path="String"/>
</f></readUTFBytes>
		<readUTF public="1" set="method"><f a=""><c path="String"/></f></readUTF>
		<readShort public="1" set="method"><f a=""><x path="Int"/></f></readShort>
		<readObject public="1" set="method"><f a=""><d/></f></readObject>
		<readMultiByte public="1" set="method"><f a="length:charSet">
	<x path="UInt"/>
	<c path="String"/>
	<c path="String"/>
</f></readMultiByte>
		<readInt public="1" set="method"><f a=""><x path="Int"/></f></readInt>
		<readFloat public="1" set="method"><f a=""><x path="Float"/></f></readFloat>
		<readDouble public="1" set="method"><f a=""><x path="Float"/></f></readDouble>
		<readBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></readBytes>
		<readByte public="1" set="method"><f a=""><x path="Int"/></f></readByte>
		<readBoolean public="1" set="method"><f a=""><x path="Bool"/></f></readBoolean>
		<objectEncoding public="1"><x path="UInt"/></objectEncoding>
		<endian public="1"><e path="flash.utils.Endian"/></endian>
		<bytesAvailable public="1" set="null"><x path="UInt"/></bytesAvailable>
	</class>
	<class path="flash.utils.IDataInput2" params="" file="/usr/lib/haxe/std/flash/utils/IDataInput2.hx" extern="1" interface="1"><extends path="flash.utils.IDataInput"/></class>
	<class path="flash.utils.IDataOutput" params="" file="/usr/lib/haxe/std/flash/utils/IDataOutput.hx" extern="1" interface="1">
		<writeUnsignedInt public="1" set="method"><f a="value">
	<x path="UInt"/>
	<x path="Void"/>
</f></writeUnsignedInt>
		<writeUTFBytes public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTFBytes>
		<writeUTF public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTF>
		<writeShort public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeShort>
		<writeObject public="1" set="method"><f a="object">
	<d/>
	<x path="Void"/>
</f></writeObject>
		<writeMultiByte public="1" set="method"><f a="value:charSet">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></writeMultiByte>
		<writeInt public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeInt>
		<writeFloat public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></writeFloat>
		<writeDouble public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></writeDouble>
		<writeBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></writeBytes>
		<writeByte public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBoolean public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Void"/>
</f></writeBoolean>
		<objectEncoding public="1"><x path="UInt"/></objectEncoding>
		<endian public="1"><e path="flash.utils.Endian"/></endian>
	</class>
	<class path="flash.utils.IDataOutput2" params="" file="/usr/lib/haxe/std/flash/utils/IDataOutput2.hx" extern="1" interface="1"><extends path="flash.utils.IDataOutput"/></class>
	<class path="flash.utils.ByteArray" params="" file="/usr/lib/haxe/std/flash/utils/ByteArray.hx" extern="1">
		<implements path="flash.utils.IDataInput2"/>
		<implements path="flash.utils.IDataOutput2"/>
		<defaultObjectEncoding public="1" static="1"><x path="UInt"/></defaultObjectEncoding>
		<writeUnsignedInt public="1" set="method"><f a="value">
	<x path="UInt"/>
	<x path="Void"/>
</f></writeUnsignedInt>
		<writeUTFBytes public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTFBytes>
		<writeUTF public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTF>
		<writeShort public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeShort>
		<writeObject public="1" set="method"><f a="object">
	<d/>
	<x path="Void"/>
</f></writeObject>
		<writeMultiByte public="1" set="method"><f a="value:charSet">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></writeMultiByte>
		<writeInt public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeInt>
		<writeFloat public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></writeFloat>
		<writeDouble public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></writeDouble>
		<writeBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></writeBytes>
		<writeByte public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBoolean public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Void"/>
</f></writeBoolean>
		<uncompress public="1" set="method"><f a="?algorithm">
	<e path="flash.utils.CompressionAlgorithm"/>
	<x path="Void"/>
</f></uncompress>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<readUnsignedShort public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedShort>
		<readUnsignedInt public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedInt>
		<readUnsignedByte public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedByte>
		<readUTFBytes public="1" set="method"><f a="length">
	<x path="UInt"/>
	<c path="String"/>
</f></readUTFBytes>
		<readUTF public="1" set="method"><f a=""><c path="String"/></f></readUTF>
		<readShort public="1" set="method"><f a=""><x path="Int"/></f></readShort>
		<readObject public="1" set="method"><f a=""><d/></f></readObject>
		<readMultiByte public="1" set="method"><f a="length:charSet">
	<x path="UInt"/>
	<c path="String"/>
	<c path="String"/>
</f></readMultiByte>
		<readInt public="1" set="method"><f a=""><x path="Int"/></f></readInt>
		<readFloat public="1" set="method"><f a=""><x path="Float"/></f></readFloat>
		<readDouble public="1" set="method"><f a=""><x path="Float"/></f></readDouble>
		<readBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></readBytes>
		<readByte public="1" set="method"><f a=""><x path="Int"/></f></readByte>
		<readBoolean public="1" set="method"><f a=""><x path="Bool"/></f></readBoolean>
		<inflate public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</inflate>
		<deflate public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</deflate>
		<compress public="1" set="method"><f a="?algorithm">
	<e path="flash.utils.CompressionAlgorithm"/>
	<x path="Void"/>
</f></compress>
		<clear public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</clear>
		<position public="1"><x path="UInt"/></position>
		<objectEncoding public="1"><x path="UInt"/></objectEncoding>
		<length public="1"><x path="UInt"/></length>
		<endian public="1"><e path="flash.utils.Endian"/></endian>
		<bytesAvailable public="1" set="null"><x path="UInt"/></bytesAvailable>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<enum path="flash.utils.CompressionAlgorithm" params="" file="/usr/lib/haxe/std/flash/utils/CompressionAlgorithm.hx">
		<ZLIB/>
		<LZMA/>
		<DEFLATE/>
		<meta>
			<m n=":fakeEnum"><e>String</e></m>
			<m n=":require"><e>flash11</e></m>
		</meta>
	</enum>
	<class path="flash.utils.Dictionary" params="" file="/usr/lib/haxe/std/flash/utils/Dictionary.hx" extern="1">
		<new public="1" set="method"><f a="?weakKeys">
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<enum path="flash.utils.Endian" params="" file="/usr/lib/haxe/std/flash/utils/Endian.hx">
		<LITTLE_ENDIAN/>
		<BIG_ENDIAN/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<typedef path="flash.utils.Function" params="" file="/usr/lib/haxe/std/flash/utils/Function.hx"><d/></typedef>
	<class path="flash.utils.Namespace" params="" file="/usr/lib/haxe/std/flash/utils/Namespace.hx" extern="1">
		<uri public="1" set="null"><c path="String"/></uri>
		<prefix public="1" set="null"><d/></prefix>
		<new public="1" set="method"><f a="?prefix:?uri">
	<d/>
	<d/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<typedef path="flash.utils.Object" params="" file="/usr/lib/haxe/std/flash/utils/Object.hx"><d/></typedef>
	<class path="flash.xml.XML" params="" file="/usr/lib/haxe/std/flash/xml/XML.hx" extern="1">
		<ignoreComments public="1" static="1"><x path="Bool"/></ignoreComments>
		<ignoreProcessingInstructions public="1" static="1"><x path="Bool"/></ignoreProcessingInstructions>
		<ignoreWhitespace public="1" static="1"><x path="Bool"/></ignoreWhitespace>
		<prettyIndent public="1" static="1"><x path="Int"/></prettyIndent>
		<prettyPrinting public="1" static="1"><x path="Bool"/></prettyPrinting>
		<defaultSettings public="1" set="method" static="1"><f a=""><d/></f></defaultSettings>
		<setSettings public="1" set="method" static="1"><f a="?o">
	<d/>
	<x path="Void"/>
</f></setSettings>
		<settings public="1" set="method" static="1"><f a=""><d/></f></settings>
		<valueOf public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></valueOf>
		<toXMLString public="1" set="method"><f a=""><c path="String"/></f></toXMLString>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<toJSON public="1" set="method">
			<f a="k">
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</toJSON>
		<text public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></text>
		<setNotification public="1" set="method"><f a="f">
	<t path="flash.utils.Function"/>
	<d/>
</f></setNotification>
		<setNamespace public="1" set="method"><f a="ns">
	<d/>
	<x path="Void"/>
</f></setNamespace>
		<setName public="1" set="method"><f a="name">
	<d/>
	<x path="Void"/>
</f></setName>
		<setLocalName public="1" set="method"><f a="name">
	<d/>
	<x path="Void"/>
</f></setLocalName>
		<setChildren public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></setChildren>
		<replace public="1" set="method"><f a="propertyName:value">
	<d/>
	<d/>
	<c path="flash.xml.XML"/>
</f></replace>
		<removeNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></removeNamespace>
		<processingInstructions public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></processingInstructions>
		<prependChild public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></prependChild>
		<parent public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></parent>
		<notification public="1" set="method"><f a=""><t path="flash.utils.Function"/></f></notification>
		<normalize public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></normalize>
		<nodeKind public="1" set="method"><f a=""><c path="String"/></f></nodeKind>
		<namespaceDeclarations public="1" set="method"><f a=""><c path="Array"><d/></c></f></namespaceDeclarations>
		<namespace public="1" set="method"><f a="?prefix">
	<d/>
	<c path="flash.utils.Namespace"/>
</f></namespace>
		<name public="1" set="method"><f a=""><t path="flash.utils.Object"/></f></name>
		<localName public="1" set="method"><f a=""><t path="flash.utils.Object"/></f></localName>
		<length public="1" set="method"><f a=""><x path="Int"/></f></length>
		<insertChildBefore public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildBefore>
		<insertChildAfter public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildAfter>
		<inScopeNamespaces public="1" set="method"><f a=""><c path="Array"><d/></c></f></inScopeNamespaces>
		<hasSimpleContent public="1" set="method"><f a=""><x path="Bool"/></f></hasSimpleContent>
		<hasComplexContent public="1" set="method"><f a=""><x path="Bool"/></f></hasComplexContent>
		<elements public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></elements>
		<descendants public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></descendants>
		<copy public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></copy>
		<contains public="1" set="method"><f a="value">
	<d/>
	<x path="Bool"/>
</f></contains>
		<comments public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></comments>
		<children public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></children>
		<childIndex public="1" set="method"><f a=""><x path="Int"/></f></childIndex>
		<child public="1" set="method"><f a="propertyName">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></child>
		<attributes public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></attributes>
		<attribute public="1" set="method"><f a="arg">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></attribute>
		<appendChild public="1" set="method"><f a="child">
	<d/>
	<c path="flash.xml.XML"/>
</f></appendChild>
		<addNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></addNamespace>
		<new public="1" set="method"><f a="?value">
	<d/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
		<haxe_dynamic><c path="flash.xml.XMLList"/></haxe_dynamic>
	</class>
	<class path="flash.xml.XMLList" params="" file="/usr/lib/haxe/std/flash/xml/XMLList.hx" extern="1">
		<valueOf public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></valueOf>
		<toXMLString public="1" set="method"><f a=""><c path="String"/></f></toXMLString>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<toJSON public="1" set="method">
			<f a="k">
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</toJSON>
		<text public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></text>
		<setNamespace public="1" set="method"><f a="ns">
	<d/>
	<x path="Void"/>
</f></setNamespace>
		<setName public="1" set="method"><f a="name">
	<d/>
	<x path="Void"/>
</f></setName>
		<setLocalName public="1" set="method"><f a="name">
	<d/>
	<x path="Void"/>
</f></setLocalName>
		<setChildren public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></setChildren>
		<replace public="1" set="method"><f a="propertyName:value">
	<d/>
	<d/>
	<c path="flash.xml.XML"/>
</f></replace>
		<removeNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></removeNamespace>
		<processingInstructions public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></processingInstructions>
		<prependChild public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></prependChild>
		<parent public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></parent>
		<normalize public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></normalize>
		<nodeKind public="1" set="method"><f a=""><c path="String"/></f></nodeKind>
		<namespaceDeclarations public="1" set="method"><f a=""><c path="Array"><d/></c></f></namespaceDeclarations>
		<namespace public="1" set="method"><f a="?prefix">
	<d/>
	<c path="flash.utils.Namespace"/>
</f></namespace>
		<name public="1" set="method"><f a=""><t path="flash.utils.Object"/></f></name>
		<localName public="1" set="method"><f a=""><t path="flash.utils.Object"/></f></localName>
		<length public="1" set="method"><f a=""><x path="Int"/></f></length>
		<insertChildBefore public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildBefore>
		<insertChildAfter public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildAfter>
		<inScopeNamespaces public="1" set="method"><f a=""><c path="Array"><d/></c></f></inScopeNamespaces>
		<hasSimpleContent public="1" set="method"><f a=""><x path="Bool"/></f></hasSimpleContent>
		<hasComplexContent public="1" set="method"><f a=""><x path="Bool"/></f></hasComplexContent>
		<elements public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></elements>
		<descendants public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></descendants>
		<copy public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></copy>
		<contains public="1" set="method"><f a="value">
	<d/>
	<x path="Bool"/>
</f></contains>
		<comments public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></comments>
		<children public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></children>
		<childIndex public="1" set="method"><f a=""><x path="Int"/></f></childIndex>
		<child public="1" set="method"><f a="propertyName">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></child>
		<attributes public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></attributes>
		<attribute public="1" set="method"><f a="arg">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></attribute>
		<appendChild public="1" set="method"><f a="child">
	<d/>
	<c path="flash.xml.XML"/>
</f></appendChild>
		<addNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></addNamespace>
		<new public="1" set="method"><f a="?value">
	<d/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="haxe.EnumTools" params="" file="/usr/lib/haxe/std/haxe/EnumTools.hx" extern="1">
		<getName public="1" params="T" get="inline" set="null" line="41" static="1">
			<f a="e">
				<x path="Enum"><c path="getName.T"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum [e], including its path.
		
		If [e] is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
			pack1.pack2.(...).packN.EnumName
		If [e] is a sub-type of a haxe module, that module is not part of the
		package structure.
			
		If [e] has no package, the enum name is returned.
		
		If [e] is null, the result is unspecified.
		
		The enum name does not include any type parameters.</haxe_doc>
		</getName>
		<createByName public="1" params="T" get="inline" set="null" line="54" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createByName.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createByName.T"/>
			</f>
			<haxe_doc>Creates an instance of enum [e] by calling its constructor [constr] with
		arguments [params].
		
		If [e] or [constr] is null, or if enum [e] has no constructor named
		[constr], or if the number of elements in [params] does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createByName>
		<createByIndex public="1" params="T" get="inline" set="null" line="70" static="1">
			<f a="e:index:?params">
				<x path="Enum"><c path="createByIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createByIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum [e] by calling its constructor number
		[index] with arguments [params].
		
		The constructor indices are preserved from haxe syntax, so the first
		declared is index 0, the next index 1 etc.
		
		If [e] or [constr] is null, or if enum [e] has no constructor named
		[constr], or if the number of elements in [params] does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createByIndex>
		<createAll public="1" params="T" get="inline" set="null" line="87" static="1">
			<f a="e">
				<x path="Enum"><c path="createAll.T"/></x>
				<c path="Array"><c path="createAll.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum [e] that require no
		arguments.
		
		This may return the empty Array [] if all constructors of [e] require
		arguments.
		
		Otherwise an instance of [e] constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.
		
		If [e] is null, the result is unspecified.</haxe_doc>
		</createAll>
		<getConstructors public="1" params="T" get="inline" set="null" line="99" static="1">
			<f a="e">
				<x path="Enum"><c path="getConstructors.T"/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum [e].
		
		The order of the constructor names in the returned Array is preserved
		from the original syntax.
		
		If [c] is null, the result is unspecified.</haxe_doc>
		</getConstructors>
	</class>
	<class path="haxe.EnumValueTools" params="" file="/usr/lib/haxe/std/haxe/EnumTools.hx" module="haxe.EnumTools" extern="1">
		<equals public="1" params="T" get="inline" set="null" line="114" static="1">
			<f a="a:b">
				<c path="equals.T"/>
				<c path="equals.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances [a] and [b] by value.
		
		Unlike [a] == [b], this function performs a deep equality check on the
		arguments of the constructors, if exists.
		
		If [a] or [b] are null, the result is unspecified.</haxe_doc>
		</equals>
		<getName public="1" get="inline" set="null" line="125" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance [e].
		
		The result String does not contain any constructor arguments.
		
		If [e] is null, the result is unspecified.</haxe_doc>
		</getName>
		<getParameters public="1" get="inline" set="null" line="139" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance [e].
		
		If [e] has no arguments, the result is [].
		
		Otherwise the result are the values that were used as arguments to [e],
		in the order of their declaration.
		
		If [e] is null, the result is unspecified.</haxe_doc>
		</getParameters>
		<getIndex public="1" get="inline" set="null" line="151" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of enum instance [e].
		
		This corresponds to the original syntactic position of [e]. The index of
		the first declared constructor is 0, the next one is 1 etc.
		
		If [e] is null, the result is unspecified.</haxe_doc>
		</getIndex>
	</class>
	<class path="haxe.Log" params="" file="/usr/lib/haxe/std/haxe/Log.hx">
		<trace public="1" set="dynamic" line="45" static="1">
			<f a="v:?infos">
				<d/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Outputs [v] in a platform-dependent way.

		The second parameter [infos] is injected by the compiler and contains
		information about the position where the trace() call was made.

		This method can be rebound to a custom function:
			var oldTrace = haxe.Log.trace; // store old function
			haxe.Log.trace = function(v,infos) { // handle trace }
			...
			haxe.Log.trace = oldTrace;

		If it is bound to null, subsequent calls to trace() will cause an
		exception.</haxe_doc>
		</trace>
		<haxe_doc>Log primarily provides the trace() method, which is invoked upon a call to
	trace() in haxe code.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<typedef path="haxe.PosInfos" params="" file="/usr/lib/haxe/std/haxe/PosInfos.hx">
		<a>
			<methodName><c path="String"/></methodName>
			<lineNumber><x path="Int"/></lineNumber>
			<fileName><c path="String"/></fileName>
			<customParams>
				<c path="Array"><d/></c>
				<meta><m n=":optional"/></meta>
			</customParams>
			<className><c path="String"/></className>
		</a>
		<haxe_doc>PosInfos is a magic type which can be used to generate position information
	into the output for debugging use.
	
	If a function has a final optional argument of this type, i.e.
	(..., ?pos:haxe.PosInfos), each call to that function which does not assign
	a value to that argument has its position added as call argument.
	
	This can be used to track positions of calls in e.g. a unit testing
	framework.</haxe_doc>
	</typedef>
	<class path="haxe.Timer" params="" file="/usr/lib/haxe/lib/nme/4,0,2/haxe/Timer.hx">
		<delay public="1" set="method" line="54" static="1">
			<f a="f:time_ms">
				<f a=""><x path="Void"/></f>
				<x path="Int"/>
				<c path="haxe.Timer"/>
			</f>
			<haxe_doc>This will delay the call to [f] for the given time. [f] will only be called once.</haxe_doc>
		</delay>
		<measure public="1" params="T" set="method" line="68" static="1">
			<f a="f:?pos">
				<f a=""><c path="measure.T"/></f>
				<t path="haxe.PosInfos"/>
				<c path="measure.T"/>
			</f>
			<haxe_doc>Measure the time it takes to execute the function [f] and trace it. Returns the value returned by [f].</haxe_doc>
		</measure>
		<stamp public="1" set="method" line="78" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the most precise timestamp, in seconds. The value itself might differ depending on platforms, only differences between two values make sense.</haxe_doc>
		</stamp>
		<run public="1" set="dynamic" line="48">
			<f a=""><x path="Void"/></f>
			<haxe_doc>This is the [run()] method that is called when the Timer executes. It can be either overriden in subclasses or directly rebinded with another function-value.</haxe_doc>
		</run>
		<stop public="1" set="method" line="32">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Stop the timer definitely.</haxe_doc>
		</stop>
		<id><t path="Null"><x path="Int"/></t></id>
		<new public="1" set="method" line="16">
			<f a="time_ms">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Create a new timer that will run every [time_ms] (in milliseconds).</haxe_doc>
		</new>
	</class>
	<abstract path="haxe.ds.HashMap" params="K:V" file="/usr/lib/haxe/std/haxe/ds/HashMap.hx"/>
	<class path="haxe.ds.ObjectMap" params="K:V" file="/usr/lib/haxe/std/flash/_std/haxe/ds/ObjectMap.hx">
		<extends path="flash.utils.Dictionary"/>
		<implements path="IMap">
			<c path="haxe.ds.ObjectMap.K"/>
			<c path="haxe.ds.ObjectMap.V"/>
		</implements>
		<iterator public="1" set="method" line="46"><f a=""><t path="Iterator"><c path="haxe.ds.ObjectMap.V"/></t></f></iterator>
		<remove public="1" set="method" line="22"><f a="key">
	<c path="haxe.ds.ObjectMap.K"/>
	<x path="Bool"/>
</f></remove>
		<exists public="1" get="inline" set="null" line="18"><f a="key">
	<c path="haxe.ds.ObjectMap.K"/>
	<x path="Bool"/>
</f></exists>
		<set public="1" get="inline" set="null" line="14"><f a="key:value">
	<c path="haxe.ds.ObjectMap.K"/>
	<c path="haxe.ds.ObjectMap.V"/>
	<x path="Void"/>
</f></set>
		<get public="1" get="inline" set="null" line="10"><f a="key">
	<c path="haxe.ds.ObjectMap.K"/>
	<t path="Null"><c path="haxe.ds.ObjectMap.V"/></t>
</f></get>
		<new public="1" set="method" line="6"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.ds._ObjectMap.NativeValueIterator" params="" file="/usr/lib/haxe/std/flash/_std/haxe/ds/ObjectMap.hx" private="1" module="haxe.ds.ObjectMap">
		<next public="1" get="inline" set="null" line="114"><f a=""><d/></f></next>
		<hasNext public="1" get="inline" set="null" line="105"><f a=""><x path="Bool"/></f></hasNext>
		<index><x path="Int"/></index>
		<collection><d/></collection>
		<new set="method" line="103"><f a=""><x path="Void"/></f></new>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.ds.StringMap" params="T" file="/usr/lib/haxe/std/flash/_std/haxe/ds/StringMap.hx">
		<implements path="IMap">
			<c path="String"/>
			<c path="haxe.ds.StringMap.T"/>
		</implements>
		<iterator public="1" set="method" line="55">
			<f a=""><t path="Iterator"><c path="haxe.ds.StringMap.T"/></t></f>
			<haxe_doc>Returns an iterator of all values in the hashtable.</haxe_doc>
		</iterator>
		<remove public="1" set="method" line="44">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes a hashtable entry. Returns [true] if
		there was such entry.</haxe_doc>
		</remove>
		<exists public="1" set="method" line="40">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if a value exists for the given key.
		In particular, it's useful to tells if a key has
		a [null] value versus no value.</haxe_doc>
		</exists>
		<get public="1" set="method" line="36">
			<f a="key">
				<c path="String"/>
				<t path="Null"><c path="haxe.ds.StringMap.T"/></t>
			</f>
			<haxe_doc>Get a value for the given key.</haxe_doc>
		</get>
		<set public="1" set="method" line="32">
			<f a="key:value">
				<c path="String"/>
				<c path="haxe.ds.StringMap.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set a value for the given key.</haxe_doc>
		</set>
		<h><c path="flash.utils.Dictionary"/></h>
		<new public="1" set="method" line="28">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new empty hashtable.</haxe_doc>
		</new>
		<haxe_doc>Hashtable over a set of elements, using [String] as keys.
	Other kind of keys are not possible on all platforms since they
	can't always be implemented efficiently.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.rtti.Meta" params="" file="/usr/lib/haxe/std/haxe/rtti/Meta.hx">
		<getFields public="1" set="method" line="56" static="1">
			<f a="t">
				<d/>
				<d><d><c path="Array"><d/></c></d></d>
			</f>
			<haxe_doc>Returns the metadata that were declared for the given class fields or enum constructors</haxe_doc>
		</getFields>
		<haxe_doc>An api to access classes and enums metadata at runtime.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="integration.moduleinittests.ModuleInitTests" params="" file="test/integration/moduleinittests/ModuleInitTests.hx">
		<moduleInit_spritePostAutoInit_notNull public="1" set="method" line="134"><f a=""><x path="Void"/></f></moduleInit_spritePostAutoInit_notNull>
		<moduleInit_spriteNoAutoInit_null public="1" set="method" line="125"><f a=""><x path="Void"/></f></moduleInit_spriteNoAutoInit_null>
		<moduleInit_spriteAutoInit_notNull public="1" set="method" line="116"><f a=""><x path="Void"/></f></moduleInit_spriteAutoInit_notNull>
		<moduleInit_movieClipPostAutoInit_notNull public="1" set="method" line="103"><f a=""><x path="Void"/></f></moduleInit_movieClipPostAutoInit_notNull>
		<moduleInit_movieClipNoAutoInit_null public="1" set="method" line="94"><f a=""><x path="Void"/></f></moduleInit_movieClipNoAutoInit_null>
		<moduleInit_movieClipAutoInit_notNull public="1" set="method" line="86"><f a=""><x path="Void"/></f></moduleInit_movieClipAutoInit_notNull>
		<moduleInit_corePostAutoInit_notNull public="1" set="method" line="73"><f a=""><x path="Void"/></f></moduleInit_corePostAutoInit_notNull>
		<moduleInit_coreNoAutoInit_null public="1" set="method" line="64"><f a=""><x path="Void"/></f></moduleInit_coreNoAutoInit_null>
		<moduleInit_coreAutoInit_notNull public="1" set="method" line="55"><f a=""><x path="Void"/></f></moduleInit_coreAutoInit_notNull>
		<runAfterEveryTest public="1" set="method" line="44"><f a=""><x path="Void"/></f></runAfterEveryTest>
		<module><d/></module>
		<new public="1" set="method" line="17"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="mvcexpress.modules.ModuleCore" params="" file="mvcexpress/modules/ModuleCore.hx">
		<listMappedCommands public="1" set="method" line="159">
			<f a=""><c path="String"/></f>
			<haxe_doc>* List all controller mappings.</haxe_doc>
		</listMappedCommands>
		<listMappedProxies public="1" set="method" line="152">
			<f a=""><c path="String"/></f>
			<haxe_doc>* List all model mappings.</haxe_doc>
		</listMappedProxies>
		<listMappedMediators public="1" set="method" line="145">
			<f a=""><c path="String"/></f>
			<haxe_doc>* List all view mappings.</haxe_doc>
		</listMappedMediators>
		<listMappedMessages public="1" set="method" line="138">
			<f a=""><c path="String"/></f>
			<haxe_doc>* List all message mappings.</haxe_doc>
		</listMappedMessages>
		<unregisterScope set="method" line="128">
			<f a="scopeName">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Unregisters scope name.
	 * Then scope is not registered module to module communication via scope and mapping proxies to scope becomes not possible.
	 *</haxe_doc>
		</unregisterScope>
		<registerScope set="method" line="119">
			<f a="scopeName:?messageSending:?messageReceiving:?proxieMapping">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Registers scope name.
	 * If scope name is not registered - module to module communication via scope and mapping proxies to scope is not possible.
	 * What features module can use with that scope is defined by parameters.
	 * 
	 * 
	 * 
	 *</haxe_doc>
		</registerScope>
		<sendScopeMessage set="method" line="106">
			<f a="scopeName:type:?params">
				<c path="String"/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sends scoped module to module message, all modules that are listening to specified scopeName and message type will get it.
	 * 
	 * 
	 *</haxe_doc>
		</sendScopeMessage>
		<sendMessage set="method" line="96">
			<f a="type:?params">
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Message sender.
	 * 
	 *</haxe_doc>
		</sendMessage>
		<onDispose set="method" line="87">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Function called before module is destroyed.
	 * Meant to be overridden.</haxe_doc>
		</onDispose>
		<disposeModule public="1" set="method" line="78">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Function to get rid of module.
	 * - All module commands are unmapped.
	 * - All module mediators are unmediated
	 * - All module proxies are unmapped
	 * - All internals are nulled.</haxe_doc>
		</disposeModule>
		<onInit set="method" line="67">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Function called after framework is initialized.
	 * Meant to be overridden.</haxe_doc>
		</onInit>
		<initModule set="method" line="55">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Initializes module. If this function is not called module will not work properly.
	 * By default it is called in constructor, but you can do it manually if you set constructor parameter 'autoInit' to false.</haxe_doc>
		</initModule>
		<get_moduleName public="1" set="method" line="47">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Name of the module</haxe_doc>
		</get_moduleName>
		<commandMap><c path="mvcexpress.core.CommandMap"/></commandMap>
		<mediatorMap><c path="mvcexpress.core.MediatorMap"/></mediatorMap>
		<proxyMap><c path="mvcexpress.core.ProxyMap"/></proxyMap>
		<moduleBase><c path="mvcexpress.core.ModuleBase"/></moduleBase>
		<moduleName public="1" get="accessor" set="null"><c path="String"/></moduleName>
		<new public="1" set="method" line="32">
			<f a="?moduleName:?autoInit">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* CONSTRUCTOR
	 *</haxe_doc>
		</new>
	</class>
	<class path="integration.moduleinittests.testobj.InitTestModuleCore" params="" file="test/integration/moduleinittests/testobj/InitTestModuleCore.hx">
		<extends path="mvcexpress.modules.ModuleCore"/>
		<NAME public="1" line="14" static="1"><c path="String"/></NAME>
		<getMediatorMap public="1" set="method" line="37"><f a=""><c path="mvcexpress.core.MediatorMap"/></f></getMediatorMap>
		<getCommandMap public="1" set="method" line="33"><f a=""><c path="mvcexpress.core.CommandMap"/></f></getCommandMap>
		<getProxyMap public="1" set="method" line="29"><f a=""><c path="mvcexpress.core.ProxyMap"/></f></getProxyMap>
		<onDispose set="method" line="26" override="1"><f a=""><x path="Void"/></f></onDispose>
		<start public="1" set="method" line="22"><f a=""><x path="Void"/></f></start>
		<onInit set="method" line="19" override="1"><f a=""><x path="Void"/></f></onInit>
		<new public="1" set="method" line="15"><f a="autoInit">
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="mvcexpress.modules.ModuleMovieClip" params="" file="mvcexpress/modules/ModuleMovieClip.hx">
		<extends path="flash.display.MovieClip"/>
		<listMappedCommands public="1" set="method" line="179">
			<f a=""><c path="String"/></f>
			<haxe_doc>* List all controller mappings.</haxe_doc>
		</listMappedCommands>
		<listMappedProxies public="1" set="method" line="172">
			<f a=""><c path="String"/></f>
			<haxe_doc>* List all model mappings.</haxe_doc>
		</listMappedProxies>
		<listMappedMediators public="1" set="method" line="165">
			<f a=""><c path="String"/></f>
			<haxe_doc>* List all view mappings.</haxe_doc>
		</listMappedMediators>
		<listMappedMessages public="1" set="method" line="158">
			<f a=""><c path="String"/></f>
			<haxe_doc>* List all message mappings.</haxe_doc>
		</listMappedMessages>
		<unregisterScope set="method" line="148">
			<f a="scopeName">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Unregisters scope name.
	 * Then scope is not registered module to module communication via scope and mapping proxies to scope becomes not possible.
	 *</haxe_doc>
		</unregisterScope>
		<registerScope set="method" line="139">
			<f a="scopeName:?messageSending:?messageReceiving:?proxieMapping">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Registers scope name.
	 * If scope name is not registered - module to module communication via scope and mapping proxies to scope is not possible.
	 * What features module can use with that scope is defined by parameters.
	 * 
	 * 
	 * 
	 *</haxe_doc>
		</registerScope>
		<sendScopeMessage set="method" line="126">
			<f a="scopeName:type:?params">
				<c path="String"/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sends scoped module to module message, all modules that are listening to specified scopeName and message type will get it.
	 * 
	 * 
	 *</haxe_doc>
		</sendScopeMessage>
		<sendMessage set="method" line="116">
			<f a="type:?params">
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Message sender.
	 * 
	 *</haxe_doc>
		</sendMessage>
		<onDispose set="method" line="107">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Function called before module is destroyed.
	 * Meant to be overridden.</haxe_doc>
		</onDispose>
		<disposeModule public="1" set="method" line="98">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Function to get rid of module.
	 * - All module commands are unmapped.
	 * - All module mediators are unmediated
	 * - All module proxies are unmapped
	 * - All internals are nulled.</haxe_doc>
		</disposeModule>
		<onInit set="method" line="87">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Function called after framework is initialized.
	 * Meant to be overridden.</haxe_doc>
		</onInit>
		<initModule set="method" line="75">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Initializes module. If this function is not called module will not work properly.
	 * By default it is called in constructor, but you can do it manually if you set constructor parameter 'autoInit' to false.</haxe_doc>
		</initModule>
		<get_moduleName public="1" set="method" line="67">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Name of the module</haxe_doc>
		</get_moduleName>
		<handleModuleAddedToStage set="method" line="59"><f a="event">
	<t path="nme.events.Event"/>
	<x path="Void"/>
</f></handleModuleAddedToStage>
		<commandMap><c path="mvcexpress.core.CommandMap"/></commandMap>
		<mediatorMap><c path="mvcexpress.core.MediatorMap"/></mediatorMap>
		<proxyMap><c path="mvcexpress.core.ProxyMap"/></proxyMap>
		<moduleBase><c path="mvcexpress.core.ModuleBase"/></moduleBase>
		<moduleName public="1" get="accessor" set="null"><c path="String"/></moduleName>
		<new public="1" set="method" line="35">
			<f a="?moduleName:?autoInit:?initOnStage">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* CONSTRUCTOR
	 * 
	 * 
	 *</haxe_doc>
		</new>
	</class>
	<class path="integration.moduleinittests.testobj.InitTestModuleMovieClip" params="" file="test/integration/moduleinittests/testobj/InitTestModuleMovieClip.hx">
		<extends path="mvcexpress.modules.ModuleMovieClip"/>
		<NAME public="1" line="14" static="1"><c path="String"/></NAME>
		<getMediatorMap public="1" set="method" line="37"><f a=""><c path="mvcexpress.core.MediatorMap"/></f></getMediatorMap>
		<getCommandMap public="1" set="method" line="33"><f a=""><c path="mvcexpress.core.CommandMap"/></f></getCommandMap>
		<getProxyMap public="1" set="method" line="29"><f a=""><c path="mvcexpress.core.ProxyMap"/></f></getProxyMap>
		<onDispose set="method" line="26" override="1"><f a=""><x path="Void"/></f></onDispose>
		<start public="1" set="method" line="22"><f a=""><x path="Void"/></f></start>
		<onInit set="method" line="19" override="1"><f a=""><x path="Void"/></f></onInit>
		<new public="1" set="method" line="15"><f a="autoInit">
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="mvcexpress.modules.ModuleSprite" params="" file="mvcexpress/modules/ModuleSprite.hx">
		<extends path="flash.display.Sprite"/>
		<listMappedCommands public="1" set="method" line="180">
			<f a=""><c path="String"/></f>
			<haxe_doc>* List all controller mappings.</haxe_doc>
		</listMappedCommands>
		<listMappedProxies public="1" set="method" line="173">
			<f a=""><c path="String"/></f>
			<haxe_doc>* List all model mappings.</haxe_doc>
		</listMappedProxies>
		<listMappedMediators public="1" set="method" line="166">
			<f a=""><c path="String"/></f>
			<haxe_doc>* List all view mappings.</haxe_doc>
		</listMappedMediators>
		<listMappedMessages public="1" set="method" line="159">
			<f a=""><c path="String"/></f>
			<haxe_doc>* List all message mappings.</haxe_doc>
		</listMappedMessages>
		<unregisterScope set="method" line="149">
			<f a="scopeName">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Unregisters scope name.
	 * Then scope is not registered module to module communication via scope and mapping proxies to scope becomes not possible.
	 *</haxe_doc>
		</unregisterScope>
		<registerScope set="method" line="140">
			<f a="scopeName:?messageSending:?messageReceiving:?proxieMapping">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Registers scope name.
	 * If scope name is not registered - module to module communication via scope and mapping proxies to scope is not possible.
	 * What features module can use with that scope is defined by parameters.
	 * 
	 * 
	 * 
	 *</haxe_doc>
		</registerScope>
		<sendScopeMessage set="method" line="127">
			<f a="scopeName:type:?params">
				<c path="String"/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sends scoped module to module message, all modules that are listening to specified scopeName and message type will get it.
	 * 
	 * 
	 *</haxe_doc>
		</sendScopeMessage>
		<sendMessage set="method" line="117">
			<f a="type:?params">
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Message sender.
	 * 
	 *</haxe_doc>
		</sendMessage>
		<onDispose set="method" line="108">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Function called before module is destroyed.
	 * Meant to be overridden.</haxe_doc>
		</onDispose>
		<disposeModule public="1" set="method" line="99">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Function to get rid of module.
	 * - All module commands are unmapped.
	 * - All module mediators are unmediated
	 * - All module proxies are unmapped
	 * - All internals are nulled.</haxe_doc>
		</disposeModule>
		<onInit set="method" line="88">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Function called after framework is initialized.
	 * Meant to be overridden.</haxe_doc>
		</onInit>
		<initModule set="method" line="76">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Initializes module. If this function is not called module will not work properly.
	 * By default it is called in constructor, but you can do it manually if you set constructor parameter 'autoInit' to false.</haxe_doc>
		</initModule>
		<get_moduleName public="1" set="method" line="68">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Name of the module</haxe_doc>
		</get_moduleName>
		<handleModuleAddedToStage set="method" line="60"><f a="event">
	<t path="nme.events.Event"/>
	<x path="Void"/>
</f></handleModuleAddedToStage>
		<commandMap><c path="mvcexpress.core.CommandMap"/></commandMap>
		<mediatorMap><c path="mvcexpress.core.MediatorMap"/></mediatorMap>
		<proxyMap><c path="mvcexpress.core.ProxyMap"/></proxyMap>
		<moduleBase><c path="mvcexpress.core.ModuleBase"/></moduleBase>
		<moduleName public="1" get="accessor" set="null"><c path="String"/></moduleName>
		<new public="1" set="method" line="36">
			<f a="?moduleName:?autoInit:?initOnStage">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* CONSTRUCTOR
	 * 
	 * 
	 *</haxe_doc>
		</new>
	</class>
	<class path="integration.moduleinittests.testobj.InitTestModuleSprite" params="" file="test/integration/moduleinittests/testobj/InitTestModuleSprite.hx">
		<extends path="mvcexpress.modules.ModuleSprite"/>
		<NAME public="1" line="14" static="1"><c path="String"/></NAME>
		<getMediatorMap public="1" set="method" line="37"><f a=""><c path="mvcexpress.core.MediatorMap"/></f></getMediatorMap>
		<getCommandMap public="1" set="method" line="33"><f a=""><c path="mvcexpress.core.CommandMap"/></f></getCommandMap>
		<getProxyMap public="1" set="method" line="29"><f a=""><c path="mvcexpress.core.ProxyMap"/></f></getProxyMap>
		<onDispose set="method" line="26" override="1"><f a=""><x path="Void"/></f></onDispose>
		<start public="1" set="method" line="22"><f a=""><x path="Void"/></f></start>
		<onInit set="method" line="19" override="1"><f a=""><x path="Void"/></f></onInit>
		<new public="1" set="method" line="15"><f a="autoInit">
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="mvcexpress.MvcExpress" params="" file="mvcexpress/MvcExpress.hx">
		<VERSION public="1" get="accessor" set="null" static="1"><c path="String"/></VERSION>
		<DEBUG_COMPILE public="1" get="accessor" set="null" static="1"><x path="Bool"/></DEBUG_COMPILE>
		<WEBSITE_URL public="1" line="17" static="1">
			<c path="String"/>
			<haxe_doc>Home website of mvcExpress.</haxe_doc>
		</WEBSITE_URL>
		<NAME public="1" line="19" static="1">
			<c path="String"/>
			<haxe_doc>Framework name</haxe_doc>
		</NAME>
		<MAJOR_VERSION public="1" line="21" static="1">
			<x path="Int"/>
			<haxe_doc>Current framework major version</haxe_doc>
		</MAJOR_VERSION>
		<MINOR_VERSION public="1" line="23" static="1">
			<x path="Int"/>
			<haxe_doc>Current framework minor version</haxe_doc>
		</MINOR_VERSION>
		<REVISION public="1" line="25" static="1">
			<x path="Int"/>
			<haxe_doc>Current framework revision version</haxe_doc>
		</REVISION>
		<get_VERSION public="1" set="method" line="28" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Current framework version</haxe_doc>
		</get_VERSION>
		<get_DEBUG_COMPILE public="1" set="method" line="37" static="1">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Checks for 'debug' variable value.
	 * If it is true framework functions has overhead code, this overhead is used for debugging and error checking.
	 * This value can help not to forget compile with '-D debug' set to false for release.</haxe_doc>
		</get_DEBUG_COMPILE>
		<pendingInjectsTimeOut public="1" line="51" static="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* Time in ms for framework to wait for missing dependencies.
	 * By default pending dependency feature is disabled, as it is set to 0. If missing injection is encountered - error will be instantly thrown.
	 * If pendingInjectsTimeOut is > 0, framework will wait this amount of time in milliseconds for missing dependencies to be mapped.
	 * If dependency is mapped during this waiting time - framework will find missing dependencies and resolve them.
	 * If in this time dependencies will not be resolved - error will be thrown.]]></haxe_doc>
		</pendingInjectsTimeOut>
		<debugFunction public="1" line="58" static="1">
			<d/>
			<haxe_doc>* Sets a debug function that will get framework activity messages as String's.
	 * CONFIG:debug  MUST be set to true for debugFunction to get any trace data frame framework.
	 * For example you can use : MvcExpress.debugFunction = trace; to trace all debug data.
	 * it is good idea to set it before initializing first module.</haxe_doc>
		</debugFunction>
		<loggerFunction line="66" static="1">
			<d/>
			<haxe_doc>* Function to get more detailed framework activity.
	 *</haxe_doc>
		</loggerFunction>
		<debug public="1" set="method" line="74" static="1">
			<f a="traceObj">
				<c path="mvcexpress.core.traceobjects.TraceObj"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Framework function for debugging.
	 * 
	 *</haxe_doc>
		</debug>
		<new public="1" set="method" line="87"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="mvcexpress.core.CommandMap" params="" file="mvcexpress/core/CommandMap.hx">
		<commandClassParamTypes line="42" static="1">
			<c path="haxe.ds.ObjectMap">
				<d/>
				<d/>
			</c>
			<haxe_doc>types of command execute function, needed for debug mode only validation of execute() parameter.</haxe_doc>
		</commandClassParamTypes>
		<validatedCommands line="45" static="1"><c path="haxe.ds.ObjectMap">
	<d/>
	<x path="Bool"/>
</c></validatedCommands>
		<listMessageCommands public="1" set="method" line="509"><f a="messageType">
	<c path="String"/>
	<c path="Array"><x path="Class"><d/></x></c>
</f></listMessageCommands>
		<validateCommandParams set="method" line="494"><f a="commandClass:params">
	<x path="Class"><d/></x>
	<d/>
	<x path="Void"/>
</f></validateCommandParams>
		<validateCommandClass public="1" set="method" line="451">
			<f a="commandClass">
				<x path="Class"><d/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>* Helper functions for error checking
	 *</haxe_doc>
		</validateCommandClass>
		<handleCommandExecute public="1" set="method" line="361">
			<f a="messageType:params">
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>function to be called by messenger on needed message type sent</haxe_doc>
		</handleCommandExecute>
		<dispose public="1" set="method" line="340">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Dispose commandMap on disposeModule()
	 *</haxe_doc>
		</dispose>
		<poolCommand public="1" set="method" line="328">
			<f a="command">
				<c path="mvcexpress.mvc.PooledCommand"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Pool command from outside of CommandMap.
	 * 
	 *</haxe_doc>
		</poolCommand>
		<listMappings public="1" set="method" line="309">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Returns text of all command classes that are mapped to messages. (for debugging)
	 *</haxe_doc>
		</listMappings>
		<mappedCommandCount public="1" set="method" line="297">
			<f a="type">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Returns count of commands mapped to specified message type.
	 * 
	 *</haxe_doc>
		</mappedCommandCount>
		<isMapped public="1" set="method" line="275">
			<f a="type:commandClass">
				<c path="String"/>
				<x path="Class"><d/></x>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Checks if Command class is already added to message type
	 * 
	 * 
	 *</haxe_doc>
		</isMapped>
		<clearCommandPool public="1" set="method" line="261">
			<f a="commandClass">
				<x path="Class"><d/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>* Clears pool created for specified command.
	 * (if commands are not pooled - function fails silently.)
	 *</haxe_doc>
		</clearCommandPool>
		<checkIsClassPooled public="1" set="method" line="251">
			<f a="commandClass">
				<x path="Class"><d/></x>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Checks if PooledCommand is already pooled.
	 * 
	 *</haxe_doc>
		</checkIsClassPooled>
		<scopeUnmap public="1" set="method" line="226">
			<f a="scopeName:type:commandClass">
				<c path="String"/>
				<c path="String"/>
				<x path="Class"><d/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>* Unmaps a class for module to module communication, to be executed then message with provided type and scopeName is sent to scope.
	 * 
	 * 
	 *</haxe_doc>
		</scopeUnmap>
		<scopeMap public="1" set="method" line="206">
			<f a="scopeName:type:commandClass">
				<c path="String"/>
				<c path="String"/>
				<x path="Class"><d/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>* Maps a class for module to module communication, to be executed then message with provided type and scopeName is sent to scope.
	 * 
	 * 
	 *</haxe_doc>
		</scopeMap>
		<execute public="1" set="method" line="128">
			<f a="commandClass:?params">
				<x path="Class"><d/></x>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Instantiates and executes provided command class, and sends params to it.
	 * 
	 *</haxe_doc>
		</execute>
		<unmap public="1" set="method" line="98">
			<f a="type:commandClass">
				<c path="String"/>
				<x path="Class"><d/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>* Unmaps a class to be executed then message with provided type is sent.
	 * 
	 *</haxe_doc>
		</unmap>
		<map public="1" set="method" line="70">
			<f a="type:commandClass">
				<c path="String"/>
				<x path="Class"><d/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>* Map a class to be executed then message with provided type is sent.
	 * 
	 *</haxe_doc>
		</map>
		<scopeHandlers><c path="Array"><c path="mvcexpress.core.messenger.HandlerVO"/></c></scopeHandlers>
		<commandPools><c path="haxe.ds.ObjectMap">
	<d/>
	<c path="Array"><c path="mvcexpress.mvc.PooledCommand"/></c>
</c></commandPools>
		<classRegistry><x path="Map">
	<c path="String"/>
	<c path="Array"><x path="Class"><d/></x></c>
</x></classRegistry>
		<mediatorMap><c path="mvcexpress.core.MediatorMap"/></mediatorMap>
		<proxyMap><c path="mvcexpress.core.ProxyMap"/></proxyMap>
		<messenger><c path="mvcexpress.core.messenger.Messenger"/></messenger>
		<moduleName><c path="String"/></moduleName>
		<new public="1" set="method" line="50">
			<f a="moduleName:messenger:proxyMap:mediatorMap">
				<c path="String"/>
				<c path="mvcexpress.core.messenger.Messenger"/>
				<c path="mvcexpress.core.ProxyMap"/>
				<c path="mvcexpress.core.MediatorMap"/>
				<x path="Void"/>
			</f>
			<haxe_doc>CONSTRUCTOR</haxe_doc>
		</new>
	</class>
	<class path="mvcexpress.core.interfaces.IMediatorMap" params="" file="mvcexpress/core/interfaces/IMediatorMap.hx" interface="1">
		<isViewMapped public="1" set="method"><f a="viewObject">
	<d/>
	<x path="Bool"/>
</f></isViewMapped>
		<unmediate public="1" set="method"><f a="viewObject">
	<d/>
	<x path="Void"/>
</f></unmediate>
		<mediateWith public="1" set="method"><f a="viewObject:mediatorClass:?injectClass">
	<d/>
	<x path="Class"><d/></x>
	<x path="Class"><d/></x>
	<x path="Void"/>
</f></mediateWith>
		<mediate public="1" set="method"><f a="viewObject">
	<d/>
	<x path="Void"/>
</f></mediate>
	</class>
	<class path="mvcexpress.core.MediatorMap" params="" file="mvcexpress/core/MediatorMap.hx">
		<implements path="mvcexpress.core.interfaces.IMediatorMap"/>
		<dispose public="1" set="method" line="277">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Dispose mediatorMap - unmediate all mediated view objects and set all internals to null.
	 *</haxe_doc>
		</dispose>
		<listMappings public="1" set="method" line="259">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Returns String of all view classes that are mapped to mediator classes. (for debugging)
	 *</haxe_doc>
		</listMappings>
		<isMediated public="1" set="method" line="251">
			<f a="viewObject">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Checks if view object is mediated.
	 *</haxe_doc>
		</isMediated>
		<isViewMapped public="1" set="method" line="237">
			<f a="viewObject">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if class of view object is mapped to any mediator.
	 *</haxe_doc>
		</isViewMapped>
		<isMapped public="1" set="method" line="225">
			<f a="viewClass:?mediatorClass">
				<x path="Class"><d/></x>
				<x path="Class"><d/></x>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Checks if mediator class is mapped to view class.
	 * 
	 * 
	 *</haxe_doc>
		</isMapped>
		<unmediate public="1" set="method" line="196">
			<f a="viewObject">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Unmediated view object
	 * If any mediator is mediating viewObject - it calls onRemove on that mediator, automatically removes all message handlers, all event listeners and disposes it.
	 *</haxe_doc>
		</unmediate>
		<mediateWith public="1" set="method" line="166">
			<f a="viewObject:mediatorClass:?injectClass">
				<d/>
				<x path="Class"><d/></x>
				<x path="Class"><d/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>* Mediates viewObject with specified mediator class.
	 * It is usually better practice to use 2 step mediation(map(), mediate()) instead of this function. But sometimes it is not possible.
	 * 
	 * 
	 *</haxe_doc>
		</mediateWith>
		<mediate public="1" set="method" line="113">
			<f a="viewObject">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* 
	 * Mediates provided viewObject with mapped mediator.
	 * Automatically instantiates mediator class(if mapped), handles all injections(including viewObject), and calls onRegister function.
	 * Throws error if mediator class is not mapped to viewObject class.
	 *</haxe_doc>
		</mediate>
		<unmap public="1" set="method" line="90">
			<f a="viewClass">
				<x path="Class"><d/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>* Unmaps any mediator class to given view class.
	 * If view is not mediated - it will fail silently.
	 *</haxe_doc>
		</unmap>
		<map public="1" set="method" line="59">
			<f a="viewClass:mediatorClass:?injectClass">
				<x path="Class"><d/></x>
				<x path="Class"><d/></x>
				<x path="Class"><d/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>* Maps mediator class to view class. Only one mediator class can mediate single instance of view class.
	 * 
	 * 
	 *</haxe_doc>
		</map>
		<mediatorRegistry><x path="Map">
	<d/>
	<c path="mvcexpress.mvc.Mediator"/>
</x></mediatorRegistry>
		<mediatorInjectRegistry><c path="haxe.ds.ObjectMap">
	<d/>
	<x path="Class"><d/></x>
</c></mediatorInjectRegistry>
		<mediatorClassRegistry><c path="haxe.ds.ObjectMap">
	<d/>
	<x path="Class"><d/></x>
</c></mediatorClassRegistry>
		<messenger><c path="mvcexpress.core.messenger.Messenger"/></messenger>
		<proxyMap><c path="mvcexpress.core.ProxyMap"/></proxyMap>
		<moduleName><c path="String"/></moduleName>
		<new public="1" set="method" line="39">
			<f a="moduleName:messenger:proxyMap">
				<c path="String"/>
				<c path="mvcexpress.core.messenger.Messenger"/>
				<c path="mvcexpress.core.ProxyMap"/>
				<x path="Void"/>
			</f>
			<haxe_doc>CONSTRUCTOR</haxe_doc>
		</new>
	</class>
	<class path="mvcexpress.core.FlexMediatorMap" params="" file="mvcexpress/core/FlexMediatorMap.hx">
		<extends path="mvcexpress.core.MediatorMap"/>
		<unmediate public="1" set="method" line="54" override="1">
			<f a="viewObject">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* If any mediator is mediating viewObject: it calls onRemove, automatically removes all handler functions listening for messages from that mediator and deletes it.
	 * If flex object is unmediated before 'creationComplete' is dispatched - nothing is done. (because mediation is not done in the first place.)
	 *</haxe_doc>
		</unmediate>
		<handleOnCreationComplete set="method" line="43">
			<f a="event">
				<c path="flash.events.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Start flex view object mediation after creationComplete is dispatched.</haxe_doc>
		</handleOnCreationComplete>
		<mediate public="1" set="method" line="32" override="1">
			<f a="viewObject">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Automatically instantiates mediator class(if mapped), handles all injections(including viewObject), and calls onRegister function.
	 * Throws error if mediator class is not mapped to viewObject class.
	 * If object is not initialized - mvcExpress will wait for 'creationComplete' to be dispatched before mediating it.
	 *</haxe_doc>
		</mediate>
		<uiComponentClass><x path="Class"><d/></x></uiComponentClass>
		<new public="1" set="method" line="21"><f a="moduleName:messenger:proxyMap:uiComponentClass">
	<c path="String"/>
	<c path="mvcexpress.core.messenger.Messenger"/>
	<c path="mvcexpress.core.ProxyMap"/>
	<x path="Class"><d/></x>
	<x path="Void"/>
</f></new>
	</class>
	<class path="mvcexpress.core.ModuleBase" params="" file="mvcexpress/core/ModuleBase.hx">
		<allowInstantiation static="1"><x path="Bool"/></allowInstantiation>
		<getModuleInstance public="1" set="method" line="72" static="1">
			<f a="moduleName:autoInit">
				<c path="String"/>
				<x path="Bool"/>
				<c path="mvcexpress.core.ModuleBase"/>
			</f>
			<haxe_doc>* Internal framework function. Not meant to be used from outside.</haxe_doc>
		</getModuleInstance>
		<getFlexClass set="method" line="214" static="1">
			<f a=""><x path="Class"><d/></x></f>
			<haxe_doc>get flex lowest class by definition. ( way to check for flex project.)</haxe_doc>
		</getFlexClass>
		<listMappedCommands public="1" set="method" line="250">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Internal framework function. Not meant to be used from outside.</haxe_doc>
		</listMappedCommands>
		<listMappedProxies public="1" set="method" line="242">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Internal framework function. Not meant to be used from outside.</haxe_doc>
		</listMappedProxies>
		<listMappedMediators public="1" set="method" line="234">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Internal framework function. Not meant to be used from outside.</haxe_doc>
		</listMappedMediators>
		<listMappedMessages public="1" set="method" line="226">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Internal framework function. Not meant to be used from outside.</haxe_doc>
		</listMappedMessages>
		<unregisterScope public="1" set="method" line="205">
			<f a="scopeName">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Unregisters scope name.
	 * Then scope is not registered module to module communication via scope and mapping proxies to scope becomes not possible.
	 *</haxe_doc>
		</unregisterScope>
		<registerScope public="1" set="method" line="195">
			<f a="scopeName:?messageSending:?messageReceiving:?proxieMap">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Registers scope name.
	 * If scope name is not registered - module to module communication via scope and mapping proxies to scope is not possible.
	 * What features module can use with that scope is defined by parameters.
	 * 
	 * 
	 * 
	 *</haxe_doc>
		</registerScope>
		<sendScopeMessage public="1" set="method" line="168">
			<f a="scopeName:type:params">
				<c path="String"/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sends scoped module to module message, all modules that are listening to specified scopeName and message type will get it.
	 * 
	 * 
	 *</haxe_doc>
		</sendScopeMessage>
		<sendMessage public="1" set="method" line="147">
			<f a="type:?params">
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sends a message with optional params object inside of current module.
	 * 
	 *</haxe_doc>
		</sendMessage>
		<disposeModule public="1" set="method" line="119">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Internal framework function. Not meant to be used from outside.</haxe_doc>
		</disposeModule>
		<initModule public="1" set="method" line="86">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Internal framework function. Not meant to be used from outside.</haxe_doc>
		</initModule>
		<get_messenger set="method" line="58">
			<f a=""><c path="mvcexpress.core.messenger.Messenger"/></f>
			<haxe_doc>* framework access to module messenger
	 *</haxe_doc>
		</get_messenger>
		<get_moduleName public="1" set="method" line="50">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Module name</haxe_doc>
		</get_moduleName>
		<_messenger>
			<c path="mvcexpress.core.messenger.Messenger"/>
			<haxe_doc>for communication.</haxe_doc>
		</_messenger>
		<mediatorMap public="1">
			<c path="mvcexpress.core.MediatorMap"/>
			<haxe_doc>Handles application Mediators.</haxe_doc>
		</mediatorMap>
		<proxyMap public="1">
			<c path="mvcexpress.core.ProxyMap"/>
			<haxe_doc>Handles application Proxies.</haxe_doc>
		</proxyMap>
		<commandMap public="1">
			<c path="mvcexpress.core.CommandMap"/>
			<haxe_doc>Handles application Commands.</haxe_doc>
		</commandMap>
		<_moduleName><c path="String"/></_moduleName>
		<messenger public="1" get="accessor" set="null"><c path="mvcexpress.core.messenger.Messenger"/></messenger>
		<moduleName public="1" get="accessor" set="null"><c path="String"/></moduleName>
		<new public="1" set="method" line="36">
			<f a="moduleName:autoInit">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Internal framework class. Not meant to be constructed.</haxe_doc>
		</new>
	</class>
	<class path="mvcexpress.core.ModuleManager" params="" file="mvcexpress/core/ModuleManager.hx">
		<_moduleId static="1"><x path="Int"/></_moduleId>
		<moduleRegistry line="28" static="1"><x path="Map">
	<c path="String"/>
	<c path="mvcexpress.core.ModuleBase"/>
</x></moduleRegistry>
		<allModules line="31" static="1"><c path="Array"><c path="mvcexpress.core.ModuleBase"/></c></allModules>
		<scopedMessengers line="33" static="1"><x path="Map">
	<c path="String"/>
	<c path="mvcexpress.core.messenger.Messenger"/>
</x></scopedMessengers>
		<scopedProxyMaps line="36" static="1"><x path="Map">
	<c path="String"/>
	<c path="mvcexpress.core.ProxyMap"/>
</x></scopedProxyMaps>
		<scopedProxiesByScope line="39" static="1"><x path="Map">
	<c path="String"/>
	<x path="Map">
		<c path="String"/>
		<c path="mvcexpress.core.ScopedProxyData"/>
	</x>
</x></scopedProxiesByScope>
		<needMetadataTest line="41" static="1"><x path="Bool"/></needMetadataTest>
		<scopePermissionsRegistry line="43" static="1"><x path="Map">
	<c path="String"/>
	<x path="Map">
		<c path="String"/>
		<c path="mvcexpress.core.ScopePermissionData"/>
	</x>
</x></scopePermissionsRegistry>
		<createModule public="1" set="method" line="54" static="1">
			<f a="moduleName:autoInit">
				<c path="String"/>
				<x path="Bool"/>
				<c path="mvcexpress.core.ModuleBase"/>
			</f>
			<haxe_doc>* Creates new module for given name.
	 *</haxe_doc>
		</createModule>
		<getMessenger public="1" set="method" line="93" static="1">
			<f a="moduleName">
				<c path="String"/>
				<c path="mvcexpress.core.messenger.Messenger"/>
			</f>
			<haxe_doc>* get messenger for module name.
	 * 
	 * 
	 *</haxe_doc>
		</getMessenger>
		<disposeModule public="1" set="method" line="103" static="1">
			<f a="moduleName">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* disposes of messenger for module name.
	 * 
	 *</haxe_doc>
		</disposeModule>
		<sendScopeMessage public="1" set="method" line="149" static="1">
			<f a="moduleName:scopeName:type:params:?checkPermisions">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<d/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>sends scoped message</haxe_doc>
		</sendScopeMessage>
		<addScopeHandler public="1" set="method" line="168" static="1">
			<f a="moduleName:scopeName:type:handler">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<d/>
				<c path="mvcexpress.core.messenger.HandlerVO"/>
			</f>
			<haxe_doc>add scoped handler</haxe_doc>
		</addScopeHandler>
		<removeScopeHandler public="1" set="method" line="189" static="1">
			<f a="scopeName:type:handler">
				<c path="String"/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>remove scoped handler</haxe_doc>
		</removeScopeHandler>
		<scopedCommandMap public="1" set="method" line="204" static="1">
			<f a="moduleName:handleCommandExecute:scopeName:type:commandClass">
				<c path="String"/>
				<d/>
				<c path="String"/>
				<c path="String"/>
				<x path="Class"><d/></x>
				<c path="mvcexpress.core.messenger.HandlerVO"/>
			</f>
			<haxe_doc>* 
	 * Map command to scoped message.
	 *</haxe_doc>
		</scopedCommandMap>
		<scopeMap public="1" set="method" line="236" static="1">
			<f a="moduleName:scopeName:proxyObject:injectClass:name">
				<c path="String"/>
				<c path="String"/>
				<c path="mvcexpress.mvc.Proxy"/>
				<x path="Class"><d/></x>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Map proxy to scope
	 * 
	 * 
	 * 
	 * 
	 * 
	 *</haxe_doc>
		</scopeMap>
		<scopeUnmap public="1" set="method" line="283" static="1">
			<f a="moduleName:scopeName:injectClass:name">
				<c path="String"/>
				<c path="String"/>
				<x path="Class"><d/></x>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Unmap proxy from scope
	 * 
	 * 
	 * 
	 * 
	 *</haxe_doc>
		</scopeUnmap>
		<injectScopedProxy public="1" set="method" line="307" static="1">
			<f a="recipientObject:injectRule">
				<d/>
				<c path="mvcexpress.core.inject.InjectRuleVO"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Inject Scoped proxy.
	 * 
	 * 
	 * 
	 *</haxe_doc>
		</injectScopedProxy>
		<addPendingScopedInjection public="1" set="method" line="325" static="1">
			<f a="scopeName:injectClassAndName:pendingInject">
				<c path="String"/>
				<c path="String"/>
				<c path="mvcexpress.core.inject.PendingInject"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds pending scoped injection.
	 *</haxe_doc>
		</addPendingScopedInjection>
		<initScopedProxyMap public="1" set="method" line="339" static="1">
			<f a="scopeName">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Initiates scoped proxy map.
	 *</haxe_doc>
		</initScopedProxyMap>
		<registerScope public="1" set="method" line="355" static="1"><f a="moduleName:scopeName:messageSending:messageReceiving:proxieMapping">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></registerScope>
		<unregisterScope public="1" set="method" line="376" static="1"><f a="moduleName:scopeName">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></unregisterScope>
		<listModules public="1" set="method" line="398" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Returns string with all module names.
	 *</haxe_doc>
		</listModules>
		<listMappedMessages public="1" set="method" line="410" static="1"><f a="moduleName">
	<c path="String"/>
	<c path="String"/>
</f></listMappedMessages>
		<listMappedMediators public="1" set="method" line="417" static="1"><f a="moduleName">
	<c path="String"/>
	<c path="String"/>
</f></listMappedMediators>
		<listMappedProxies public="1" set="method" line="425" static="1"><f a="moduleName">
	<c path="String"/>
	<c path="String"/>
</f></listMappedProxies>
		<listMappedCommands public="1" set="method" line="433" static="1"><f a="moduleName">
	<c path="String"/>
	<c path="String"/>
</f></listMappedCommands>
		<listModuleMessageCommands public="1" set="method" line="441" static="1"><f a="moduleName:key">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></listModuleMessageCommands>
		<new public="1" set="method" line="46">
			<f a=""><x path="Void"/></f>
			<haxe_doc>CONSTRUCTOR</haxe_doc>
		</new>
	</class>
	<class path="mvcexpress.core.ScopedProxyData" params="" file="mvcexpress/core/ModuleManager.hx" module="mvcexpress.core.ModuleManager">
		<injectId public="1"><c path="String"/></injectId>
		<name public="1"><c path="String"/></name>
		<injectClass public="1"><x path="Class"><d/></x></injectClass>
		<scopeName public="1"><c path="String"/></scopeName>
		<scopedProxy public="1"><c path="mvcexpress.mvc.Proxy"/></scopedProxy>
		<new public="1" set="method" line="454"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="mvcexpress.core.ScopePermissionData" params="" file="mvcexpress/core/ModuleManager.hx" module="mvcexpress.core.ModuleManager">
		<proxieMapping public="1"><x path="Bool"/></proxieMapping>
		<messageReceiving public="1"><x path="Bool"/></messageReceiving>
		<messageSending public="1"><x path="Bool"/></messageSending>
		<new public="1" set="method" line="465"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="mvcexpress.core.interfaces.IProxyMap" params="" file="mvcexpress/core/interfaces/IProxyMap.hx" interface="1"><getProxy public="1" set="method"><f a="injectClass:?name">
	<x path="Class"><d/></x>
	<c path="String"/>
	<c path="mvcexpress.mvc.Proxy"/>
</f></getProxy></class>
	<class path="mvcexpress.core.ProxyMap" params="" file="mvcexpress/core/ProxyMap.hx">
		<implements path="mvcexpress.core.interfaces.IProxyMap"/>
		<qualifiedClassNameRegistry line="39" static="1">
			<c path="haxe.ds.ObjectMap">
				<d/>
				<c path="String"/>
			</c>
			<haxe_doc>stares class QualifiedClassName by class</haxe_doc>
		</qualifiedClassNameRegistry>
		<classInjectRules line="42" static="1">
			<c path="haxe.ds.ObjectMap">
				<d/>
				<c path="Array"><c path="mvcexpress.core.inject.InjectRuleVO"/></c>
			</c>
			<haxe_doc>dictionary of (Vector of InjectRuleVO), stored by class names.</haxe_doc>
		</classInjectRules>
		<getMetaFields set="method" line="688"><f a="type">
	<x path="Class"><d/></x>
	<d/>
</f></getMetaFields>
		<getProxyById public="1" set="method" line="684"><f a="injectClassAndName">
	<c path="String"/>
	<c path="mvcexpress.mvc.Proxy"/>
</f></getProxyById>
		<getInjectByConstName set="method" line="656"><f a="constName">
	<c path="String"/>
	<c path="String"/>
</f></getInjectByConstName>
		<getInjectRules set="method" line="624">
			<f a="signatureClass">
				<x path="Class"><d/></x>
				<c path="Array"><c path="mvcexpress.core.inject.InjectRuleVO"/></c>
			</f>
			<haxe_doc>* Finds and cashes class injection point rules.</haxe_doc>
		</getInjectRules>
		<injectPendingStuff set="method" line="576">
			<f a="injectClassAndName:injectee">
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Handle all pending injections for specified key.</haxe_doc>
		</injectPendingStuff>
		<addPendingInjection public="1" set="method" line="564">
			<f a="injectClassAndName:pendingInjection">
				<c path="String"/>
				<c path="mvcexpress.core.inject.PendingInject"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds pending injection.
	 * 
	 * 
	 *</haxe_doc>
		</addPendingInjection>
		<injectStuff public="1" set="method" line="365">
			<f a="object:signatureClass:?tempValue:?tempClass">
				<d/>
				<x path="Class"><d/></x>
				<d/>
				<x path="Class"><d/></x>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Finds inject points and injects dependencies.
	 * tempValue and tempClass defines injection that will be done for current object only.
	 *</haxe_doc>
		</injectStuff>
		<dispose public="1" set="method" line="339">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Dispose of proxyMap. Remove all registered proxies and set all internals to null.
	 *</haxe_doc>
		</dispose>
		<initProxy public="1" set="method" line="323">
			<f a="proxyObject:proxyClass:injectId">
				<c path="mvcexpress.mvc.Proxy"/>
				<x path="Class"><d/></x>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Initiates proxy object.
	 * 
	 *</haxe_doc>
		</initProxy>
		<setCommandMap public="1" set="method" line="314"><f a="value">
	<c path="mvcexpress.core.CommandMap"/>
	<x path="Void"/>
</f></setCommandMap>
		<listMappings public="1" set="method" line="300">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Returns text of all mapped proxy objects, and keys they are mapped to. (for debugging)
	 *</haxe_doc>
		</listMappings>
		<isMapped public="1" set="method" line="278">
			<f a="proxyObject:?injectClass:?name">
				<c path="mvcexpress.mvc.Proxy"/>
				<x path="Class"><d/></x>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Checks if proxy object is already mapped.
	 *</haxe_doc>
		</isMapped>
		<scopeUnmap public="1" set="method" line="260">
			<f a="scopeName:injectClass:?name">
				<c path="String"/>
				<x path="Class"><d/></x>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Removes proxy mapped to scope with injectClass and name.
	 *  If mapping does not exists - it will fail silently.
	 * 
	 * 
	 *</haxe_doc>
		</scopeUnmap>
		<scopeMap public="1" set="method" line="225">
			<f a="scopeName:proxyObject:?injectClass:?name">
				<c path="String"/>
				<c path="mvcexpress.mvc.Proxy"/>
				<x path="Class"><d/></x>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Maps proxy object to the scape with injectClass and name.
	 * 
	 * 
	 * 
	 *</haxe_doc>
		</scopeMap>
		<getProxy public="1" set="method" line="198">
			<f a="injectClass:?name">
				<x path="Class"><d/></x>
				<c path="String"/>
				<c path="mvcexpress.mvc.Proxy"/>
			</f>
			<haxe_doc><![CDATA[* Get mapped proxy. This is needed to get proxy manually instead of inject it automatically. 							<br>
	 * 		You might wont to get proxy manually then your proxy has dynamic name.										<br>
	 * 		Also you might want to get proxy manually if your proxy is needed only in rare cases or only for short time.
	 * 			(for instance - you need it only in onRegister() function.)
	 * 
	 *]]></haxe_doc>
		</getProxy>
		<lazyMap public="1" set="method" line="162">
			<f a="proxyClass:?injectClass:?name:?proxyParams">
				<x path="Class"><d/></x>
				<x path="Class"><d/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc>* Stores lazy proxy data to be instantiated on first use. Proxy will be instantiated and mapped then requested for the first time.
	 * 
	
	 *</haxe_doc>
		</lazyMap>
		<unmap public="1" set="method" line="123">
			<f a="injectClass:?name">
				<x path="Class"><d/></x>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Removes proxy mapped for injection by injectClass and name.
	 *  If mapping does not exists - it will fail silently</haxe_doc>
		</unmap>
		<map public="1" set="method" line="76">
			<f a="proxyObject:?injectClass:?name">
				<c path="mvcexpress.mvc.Proxy"/>
				<x path="Class"><d/></x>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Maps proxy object to injectClass and name.
	 *</haxe_doc>
		</map>
		<classConstRegistry>
			<x path="Map">
				<c path="String"/>
				<d/>
			</x>
			<haxe_doc>Dictionary with constonts of inject names, used with constName, and constScope.</haxe_doc>
		</classConstRegistry>
		<lazyProxyRegistry>
			<x path="Map">
				<c path="String"/>
				<c path="mvcexpress.core.LazyProxyData"/>
			</x>
			<haxe_doc>dictionary of lazy Proxies, those proxies will be instantiated and mapped on first use.</haxe_doc>
		</lazyProxyRegistry>
		<pendingInjectionsRegistry>
			<x path="Map">
				<c path="String"/>
				<c path="Array"><c path="mvcexpress.core.inject.PendingInject"/></c>
			</x>
			<haxe_doc>dictionary of (Vector of PendingInject), it holds array of pending data with proxies and mediators that has pending injections,  stored by needed injection key(className + inject name).</haxe_doc>
		</pendingInjectionsRegistry>
		<injectObjectRegistry>
			<x path="Map">
				<c path="String"/>
				<c path="mvcexpress.mvc.Proxy"/>
			</x>
			<haxe_doc>all objects ready for injection stored by key. (className + inject name)</haxe_doc>
		</injectObjectRegistry>
		<commandMap><c path="mvcexpress.core.CommandMap"/></commandMap>
		<messenger><c path="mvcexpress.core.messenger.Messenger"/></messenger>
		<moduleName><c path="String"/></moduleName>
		<new public="1" set="method" line="58">
			<f a="moduleName:messenger">
				<c path="String"/>
				<c path="mvcexpress.core.messenger.Messenger"/>
				<x path="Void"/>
			</f>
			<haxe_doc>CONSTRUCTOR</haxe_doc>
		</new>
	</class>
	<class path="mvcexpress.core.LazyProxyData" params="" file="mvcexpress/core/ProxyMap.hx" module="mvcexpress.core.ProxyMap">
		<proxyParams public="1"><c path="Array"><d/></c></proxyParams>
		<name public="1"><c path="String"/></name>
		<injectClass public="1"><x path="Class"><d/></x></injectClass>
		<proxyClass public="1">
			<x path="Class"><d/></x>
			<haxe_doc>* private class to store lazy proxy data.
	 *</haxe_doc>
		</proxyClass>
		<new public="1" set="method" line="719"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="mvcexpress.core.inject.InjectRuleVO" params="" file="mvcexpress/core/inject/InjectRuleVO.hx">
		<toString public="1" set="method" line="19"><f a=""><c path="String"/></f></toString>
		<scopeName public="1">
			<c path="String"/>
			<haxe_doc>FOR INTERNAL USE ONLY. Injection identifier, formed by class name and your custom inject name.</haxe_doc>
		</scopeName>
		<injectClassAndName public="1">
			<c path="String"/>
			<haxe_doc>FOR INTERNAL USE ONLY. Injection identifier, formed by class name and your custom inject name.</haxe_doc>
		</injectClassAndName>
		<varName public="1">
			<c path="String"/>
			<haxe_doc>FOR INTERNAL USE ONLY. Name of variable to inject object into.</haxe_doc>
		</varName>
		<new public="1" set="method" line="27"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="mvcexpress.core.inject.PendingInject" params="" file="mvcexpress/core/inject/PendingInject.hx">
		<throwError set="method" line="36"><f a=""><x path="Void"/></f></throwError>
		<stopTimer public="1" set="method" line="31"><f a=""><x path="Void"/></f></stopTimer>
		<timerId><c path="haxe.Timer"/></timerId>
		<pendingInjectTime><x path="Int"/></pendingInjectTime>
		<signatureClass public="1"><x path="Class"><d/></x></signatureClass>
		<pendingObject public="1"><d/></pendingObject>
		<injectClassAndName>
			<c path="String"/>
			<haxe_doc>* Private class to store pending injection data.
	 *</haxe_doc>
		</injectClassAndName>
		<new public="1" set="method" line="22"><f a="injectClassAndName:pendingObject:signatureClass:pendingInjectTime">
	<c path="String"/>
	<d/>
	<x path="Class"><d/></x>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="mvcexpress.core.inject.TestInject" params="" file="mvcexpress/core/inject/TestInject.hx">
		<testInjectMetaTag public="1" set="method" line="17"><f a=""><x path="Bool"/></f></testInjectMetaTag>
		<metadataTest public="1"><x path="Bool"/></metadataTest>
		<new public="1" set="method" line="14"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="mvcexpress.core.messenger.HandlerVO" params="" file="mvcexpress/core/messenger/HandlerVO.hx">
		<handlerClassName public="1">
			<c path="String"/>
			<haxe_doc>FOR INTERNAL USE ONLY. Variable to store class there handler came from. (for debugging only)</haxe_doc>
		</handlerClassName>
		<isExecutable public="1">
			<x path="Bool"/>
			<haxe_doc>FOR INTERNAL USE ONLY. shows if message is handled by Command.</haxe_doc>
		</isExecutable>
		<handler public="1">
			<d/>
			<haxe_doc>FOR INTERNAL USE ONLY. function that handles message parameters, can be Mediator function or Command execute() function</haxe_doc>
		</handler>
		<new public="1" set="method" line="20"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="mvcexpress.core.messenger.Messenger" params="" file="mvcexpress/core/messenger/Messenger.hx">
		<allowInstantiation public="1" static="1"><x path="Bool"/></allowInstantiation>
		<dispose public="1" set="method" line="227">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Disposes of messenger.</haxe_doc>
		</dispose>
		<listMappings public="1" set="method" line="188">
			<f a="commandMap">
				<c path="mvcexpress.core.CommandMap"/>
				<c path="String"/>
			</f>
			<haxe_doc>* List all message mappings.
	 * Intended to be used by ModuleCore.as</haxe_doc>
		</listMappings>
		<addCommandHandler public="1" set="method" line="175">
			<f a="type:executeFunction:?handlerClass">
				<c path="String"/>
				<d/>
				<x path="Class"><d/></x>
				<c path="mvcexpress.core.messenger.HandlerVO"/>
			</f>
			<haxe_doc>* function to add command execute function.
	 *</haxe_doc>
		</addCommandHandler>
		<send public="1" set="method" line="115">
			<f a="type:?params">
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Runs all handler functions associated with message type, and send params object as single parameter.
	 * 
	 *</haxe_doc>
		</send>
		<removeHandler public="1" set="method" line="94">
			<f a="type:handler">
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Removes handler function that will be called then message of specified type is sent.
	 * - if handler is not found it fails silently.
	 * 
	 *</haxe_doc>
		</removeHandler>
		<addHandler public="1" set="method" line="52">
			<f a="type:handler:?handlerClassName">
				<c path="String"/>
				<d/>
				<c path="String"/>
				<c path="mvcexpress.core.messenger.HandlerVO"/>
			</f>
			<haxe_doc>* Adds handler function that will be called then message of specified type is sent.
	 * 
	 * 
	 * 
	 *</haxe_doc>
		</addHandler>
		<handlerRegistry><x path="Map">
	<c path="String"/>
	<c path="Array"><d/></c>
</x></handlerRegistry>
		<messageRegistry><x path="Map">
	<c path="String"/>
	<c path="Array"><c path="mvcexpress.core.messenger.HandlerVO"/></c>
</x></messageRegistry>
		<moduleName public="1"><c path="String"/></moduleName>
		<new public="1" set="method" line="34">
			<f a="moduleName">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* CONSTRUCTOR - internal class. Not available for use.</haxe_doc>
		</new>
	</class>
	<class path="mvcexpress.core.traceobjects.MvcTraceActions" params="" file="mvcexpress/core/traceobjects/MvcTraceActions.hx">
		<MODULEMANAGER_CREATEMODULE public="1" line="13" static="1"><c path="String"/></MODULEMANAGER_CREATEMODULE>
		<MODULEMANAGER_DISPOSEMODULE public="1" line="14" static="1"><c path="String"/></MODULEMANAGER_DISPOSEMODULE>
		<MODULEMANAGER_REGISTERSCOPE public="1" line="15" static="1"><c path="String"/></MODULEMANAGER_REGISTERSCOPE>
		<MODULEMANAGER_UNREGISTERSCOPE public="1" line="16" static="1"><c path="String"/></MODULEMANAGER_UNREGISTERSCOPE>
		<COMMANDMAP_MAP public="1" line="17" static="1"><c path="String"/></COMMANDMAP_MAP>
		<COMMANDMAP_UNMAP public="1" line="18" static="1"><c path="String"/></COMMANDMAP_UNMAP>
		<COMMANDMAP_EXECUTE public="1" line="19" static="1"><c path="String"/></COMMANDMAP_EXECUTE>
		<COMMANDMAP_HANDLECOMMANDEXECUTE public="1" line="20" static="1"><c path="String"/></COMMANDMAP_HANDLECOMMANDEXECUTE>
		<MEDIATORMAP_MAP public="1" line="21" static="1"><c path="String"/></MEDIATORMAP_MAP>
		<MEDIATORMAP_UNMAP public="1" line="22" static="1"><c path="String"/></MEDIATORMAP_UNMAP>
		<MEDIATORMAP_MEDIATE public="1" line="23" static="1"><c path="String"/></MEDIATORMAP_MEDIATE>
		<MEDIATORMAP_UNMEDIATE public="1" line="24" static="1"><c path="String"/></MEDIATORMAP_UNMEDIATE>
		<PROXYMAP_MAP public="1" line="25" static="1"><c path="String"/></PROXYMAP_MAP>
		<PROXYMAP_UNMAP public="1" line="26" static="1"><c path="String"/></PROXYMAP_UNMAP>
		<PROXYMAP_LAZYMAP public="1" line="27" static="1"><c path="String"/></PROXYMAP_LAZYMAP>
		<PROXYMAP_SCOPEMAP public="1" line="28" static="1"><c path="String"/></PROXYMAP_SCOPEMAP>
		<PROXYMAP_SCOPEUNMAP public="1" line="29" static="1"><c path="String"/></PROXYMAP_SCOPEUNMAP>
		<PROXYMAP_INJECTPENDING public="1" line="30" static="1"><c path="String"/></PROXYMAP_INJECTPENDING>
		<MESSENGER_ADDHANDLER public="1" line="31" static="1"><c path="String"/></MESSENGER_ADDHANDLER>
		<MESSENGER_REMOVEHANDLER public="1" line="32" static="1"><c path="String"/></MESSENGER_REMOVEHANDLER>
		<MESSENGER_SEND public="1" line="33" static="1"><c path="String"/></MESSENGER_SEND>
		<PROXYMAP_INJECTSTUFF public="1" line="37" static="1"><c path="String"/></PROXYMAP_INJECTSTUFF>
		<MESSENGER_SEND_HANDLER public="1" line="38" static="1"><c path="String"/></MESSENGER_SEND_HANDLER>
		<MODULEBASE_SENDMESSAGE public="1" line="39" static="1"><c path="String"/></MODULEBASE_SENDMESSAGE>
		<MODULEBASE_SENDMESSAGE_CLEAN public="1" line="40" static="1"><c path="String"/></MODULEBASE_SENDMESSAGE_CLEAN>
		<MODULEBASE_SENDSCOPEMESSAGE public="1" line="41" static="1"><c path="String"/></MODULEBASE_SENDSCOPEMESSAGE>
		<MODULEBASE_SENDSCOPEMESSAGE_CLEAN public="1" line="42" static="1"><c path="String"/></MODULEBASE_SENDSCOPEMESSAGE_CLEAN>
		<COMMAND_SENDMESSAGE public="1" line="43" static="1"><c path="String"/></COMMAND_SENDMESSAGE>
		<COMMAND_SENDMESSAGE_CLEAN public="1" line="44" static="1"><c path="String"/></COMMAND_SENDMESSAGE_CLEAN>
		<COMMAND_SENDSCOPEMESSAGE public="1" line="45" static="1"><c path="String"/></COMMAND_SENDSCOPEMESSAGE>
		<COMMAND_SENDSCOPEMESSAGE_CLEAN public="1" line="46" static="1"><c path="String"/></COMMAND_SENDSCOPEMESSAGE_CLEAN>
		<MEDIATOR_SENDMESSAGE public="1" line="47" static="1"><c path="String"/></MEDIATOR_SENDMESSAGE>
		<MEDIATOR_SENDMESSAGE_CLEAN public="1" line="48" static="1"><c path="String"/></MEDIATOR_SENDMESSAGE_CLEAN>
		<MEDIATOR_SENDSCOPEMESSAGE public="1" line="49" static="1"><c path="String"/></MEDIATOR_SENDSCOPEMESSAGE>
		<MEDIATOR_SENDSCOPEMESSAGE_CLEAN public="1" line="50" static="1"><c path="String"/></MEDIATOR_SENDSCOPEMESSAGE_CLEAN>
		<MEDIATOR_ADDHANDLER public="1" line="51" static="1"><c path="String"/></MEDIATOR_ADDHANDLER>
		<PROXY_SENDMESSAGE public="1" line="52" static="1"><c path="String"/></PROXY_SENDMESSAGE>
		<PROXY_SENDMESSAGE_CLEAN public="1" line="53" static="1"><c path="String"/></PROXY_SENDMESSAGE_CLEAN>
		<PROXY_SENDSCOPEMESSAGE public="1" line="54" static="1"><c path="String"/></PROXY_SENDSCOPEMESSAGE>
		<PROXY_SENDSCOPEMESSAGE_CLEAN public="1" line="55" static="1"><c path="String"/></PROXY_SENDSCOPEMESSAGE_CLEAN>
	</class>
	<class path="mvcexpress.core.traceobjects.TraceObj" params="" file="mvcexpress/core/traceobjects/TraceObj.hx">
		<toString public="1" set="method" line="21"><f a=""><c path="String"/></f></toString>
		<canPrint public="1"><x path="Bool"/></canPrint>
		<action public="1"><c path="String"/></action>
		<moduleName public="1"><c path="String"/></moduleName>
		<new public="1" set="method" line="15"><f a="action:moduleName">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="mvcexpress.core.traceobjects.TraceObj_SendMessage" params="" file="mvcexpress/core/traceobjects/TraceObj_SendMessage.hx">
		<extends path="mvcexpress.core.traceobjects.TraceObj"/>
		<mediatorObject public="1"><c path="mvcexpress.mvc.Mediator"/></mediatorObject>
		<proxyObject public="1"><c path="mvcexpress.mvc.Proxy"/></proxyObject>
		<commandObject public="1"><c path="mvcexpress.mvc.Command"/></commandObject>
		<moduleObject public="1"><c path="mvcexpress.core.ModuleBase"/></moduleObject>
		<new public="1" set="method" line="20"><f a="action:moduleName">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="mvcexpress.core.traceobjects.command.TraceCommand_sendMessage" params="" file="mvcexpress/core/traceobjects/command/TraceCommand_sendMessage.hx">
		<extends path="mvcexpress.core.traceobjects.TraceObj_SendMessage"/>
		<params public="1"><d/></params>
		<type public="1"><c path="String"/></type>
		<new public="1" set="method" line="18"><f a="moduleName:commandObject:type:params:preSend">
	<c path="String"/>
	<c path="mvcexpress.mvc.Command"/>
	<c path="String"/>
	<d/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="mvcexpress.core.traceobjects.command.TraceCommand_sendScopeMessage" params="" file="mvcexpress/core/traceobjects/command/TraceCommand_sendScopeMessage.hx">
		<extends path="mvcexpress.core.traceobjects.TraceObj_SendMessage"/>
		<params public="1"><d/></params>
		<type public="1"><c path="String"/></type>
		<new public="1" set="method" line="19"><f a="moduleName:commandObject:type:params:preSend">
	<c path="String"/>
	<c path="mvcexpress.mvc.Command"/>
	<c path="String"/>
	<d/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="mvcexpress.core.traceobjects.commandmap.TraceCommandMap_execute" params="" file="mvcexpress/core/traceobjects/commandmap/TraceCommandMap_execute.hx">
		<extends path="mvcexpress.core.traceobjects.TraceObj"/>
		<toString public="1" set="method" line="37" override="1"><f a=""><c path="String"/></f></toString>
		<messageFromCommand public="1"><c path="mvcexpress.mvc.Command"/></messageFromCommand>
		<messageFromProxy public="1"><c path="mvcexpress.mvc.Proxy"/></messageFromProxy>
		<messageFromMediator public="1"><c path="mvcexpress.mvc.Mediator"/></messageFromMediator>
		<messageFromModule public="1"><c path="mvcexpress.core.ModuleBase"/></messageFromModule>
		<view public="1"><c path="flash.display.DisplayObject"/></view>
		<params public="1"><d/></params>
		<commandClass public="1"><x path="Class"><d/></x></commandClass>
		<commandObject public="1"><c path="mvcexpress.mvc.Command"/></commandObject>
		<new public="1" set="method" line="29"><f a="moduleName:commandObject:commandClass:params">
	<c path="String"/>
	<c path="mvcexpress.mvc.Command"/>
	<x path="Class"><d/></x>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="mvcexpress.core.traceobjects.commandmap.TraceCommandMap_handleCommandExecute" params="" file="mvcexpress/core/traceobjects/commandmap/TraceCommandMap_handleCommandExecute.hx">
		<extends path="mvcexpress.core.traceobjects.TraceObj"/>
		<toString public="1" set="method" line="38" override="1"><f a=""><c path="String"/></f></toString>
		<messageFromCommand public="1"><c path="mvcexpress.mvc.Command"/></messageFromCommand>
		<messageFromProxy public="1"><c path="mvcexpress.mvc.Proxy"/></messageFromProxy>
		<messageFromMediator public="1"><c path="mvcexpress.mvc.Mediator"/></messageFromMediator>
		<messageFromModule public="1"><c path="mvcexpress.core.ModuleBase"/></messageFromModule>
		<view public="1"><c path="flash.display.DisplayObject"/></view>
		<params public="1"><d/></params>
		<type public="1"><c path="String"/></type>
		<commandClass public="1"><x path="Class"><d/></x></commandClass>
		<commandObject public="1"><c path="mvcexpress.mvc.Command"/></commandObject>
		<new public="1" set="method" line="29"><f a="moduleName:commandObject:commandClass:type:params">
	<c path="String"/>
	<c path="mvcexpress.mvc.Command"/>
	<x path="Class"><d/></x>
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="mvcexpress.core.traceobjects.commandmap.TraceCommandMap_map" params="" file="mvcexpress/core/traceobjects/commandmap/TraceCommandMap_map.hx">
		<extends path="mvcexpress.core.traceobjects.TraceObj"/>
		<toString public="1" set="method" line="22" override="1"><f a=""><c path="String"/></f></toString>
		<commandClass public="1"><x path="Class"><d/></x></commandClass>
		<type public="1"><c path="String"/></type>
		<new public="1" set="method" line="16"><f a="moduleName:type:commandClass">
	<c path="String"/>
	<c path="String"/>
	<x path="Class"><d/></x>
	<x path="Void"/>
</f></new>
	</class>
	<class path="mvcexpress.core.traceobjects.commandmap.TraceCommandMap_unmap" params="" file="mvcexpress/core/traceobjects/commandmap/TraceCommandMap_unmap.hx">
		<extends path="mvcexpress.core.traceobjects.TraceObj"/>
		<toString public="1" set="method" line="22" override="1"><f a=""><c path="String"/></f></toString>
		<commandClass public="1"><x path="Class"><d/></x></commandClass>
		<type public="1"><c path="String"/></type>
		<new public="1" set="method" line="16"><f a="moduleName:type:commandClass">
	<c path="String"/>
	<c path="String"/>
	<x path="Class"><d/></x>
	<x path="Void"/>
</f></new>
	</class>
	<class path="mvcexpress.core.traceobjects.mediator.TraceMediator_addHandler" params="" file="mvcexpress/core/traceobjects/mediator/TraceMediator_addHandler.hx">
		<extends path="mvcexpress.core.traceobjects.TraceObj"/>
		<mediatorObject public="1"><c path="mvcexpress.mvc.Mediator"/></mediatorObject>
		<handler public="1"><d/></handler>
		<type public="1"><c path="String"/></type>
		<new public="1" set="method" line="19"><f a="moduleName:mediatorObject:type:handler">
	<c path="String"/>
	<c path="mvcexpress.mvc.Mediator"/>
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="mvcexpress.core.traceobjects.mediator.TraceMediator_sendMessage" params="" file="mvcexpress/core/traceobjects/mediator/TraceMediator_sendMessage.hx">
		<extends path="mvcexpress.core.traceobjects.TraceObj_SendMessage"/>
		<params public="1"><d/></params>
		<type public="1"><c path="String"/></type>
		<new public="1" set="method" line="18"><f a="moduleName:mediatorObject:type:params:preSend">
	<c path="String"/>
	<c path="mvcexpress.mvc.Mediator"/>
	<c path="String"/>
	<d/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="mvcexpress.core.traceobjects.mediator.TraceMediator_sendScopeMessage" params="" file="mvcexpress/core/traceobjects/mediator/TraceMediator_sendScopeMessage.hx">
		<extends path="mvcexpress.core.traceobjects.TraceObj_SendMessage"/>
		<params public="1"><d/></params>
		<type public="1"><c path="String"/></type>
		<new public="1" set="method" line="18"><f a="moduleName:mediatorObject:type:params:preSend">
	<c path="String"/>
	<c path="mvcexpress.mvc.Mediator"/>
	<c path="String"/>
	<d/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="mvcexpress.core.traceobjects.mediatormap.TraceMediatorMap_map" params="" file="mvcexpress/core/traceobjects/mediatormap/TraceMediatorMap_map.hx">
		<extends path="mvcexpress.core.traceobjects.TraceObj"/>
		<toString public="1" set="method" line="22" override="1"><f a=""><c path="String"/></f></toString>
		<mediatorClass public="1"><x path="Class"><d/></x></mediatorClass>
		<viewClass public="1"><x path="Class"><d/></x></viewClass>
		<new public="1" set="method" line="16"><f a="moduleName:viewClass:mediatorClass">
	<c path="String"/>
	<x path="Class"><d/></x>
	<x path="Class"><d/></x>
	<x path="Void"/>
</f></new>
	</class>
	<class path="mvcexpress.core.traceobjects.mediatormap.TraceMediatorMap_mediate" params="" file="mvcexpress/core/traceobjects/mediatormap/TraceMediatorMap_mediate.hx">
		<extends path="mvcexpress.core.traceobjects.TraceObj"/>
		<toString public="1" set="method" line="33" override="1"><f a=""><c path="String"/></f></toString>
		<handleObjects public="1"><c path="Array"><d/></c></handleObjects>
		<dependencies public="1"><c path="Array"><d/></c></dependencies>
		<view public="1"><c path="flash.display.DisplayObject"/></view>
		<mediatorClassName public="1"><c path="String"/></mediatorClassName>
		<mediatorClass public="1"><x path="Class"><d/></x></mediatorClass>
		<viewClass public="1"><x path="Class"><d/></x></viewClass>
		<mediatorObject public="1"><c path="mvcexpress.mvc.Mediator"/></mediatorObject>
		<viewObject public="1"><d/></viewObject>
		<new public="1" set="method" line="24"><f a="moduleName:viewObject:mediatorObject:viewClass:mediatorClass:mediatorClassName">
	<c path="String"/>
	<d/>
	<c path="mvcexpress.mvc.Mediator"/>
	<x path="Class"><d/></x>
	<x path="Class"><d/></x>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="mvcexpress.core.traceobjects.mediatormap.TraceMediatorMap_unmap" params="" file="mvcexpress/core/traceobjects/mediatormap/TraceMediatorMap_unmap.hx">
		<extends path="mvcexpress.core.traceobjects.TraceObj"/>
		<toString public="1" set="method" line="20" override="1"><f a=""><c path="String"/></f></toString>
		<viewClass public="1"><x path="Class"><d/></x></viewClass>
		<new public="1" set="method" line="15"><f a="moduleName:viewClass">
	<c path="String"/>
	<x path="Class"><d/></x>
	<x path="Void"/>
</f></new>
	</class>
	<class path="mvcexpress.core.traceobjects.mediatormap.TraceMediatorMap_unmediate" params="" file="mvcexpress/core/traceobjects/mediatormap/TraceMediatorMap_unmediate.hx">
		<extends path="mvcexpress.core.traceobjects.TraceObj"/>
		<toString public="1" set="method" line="25" override="1"><f a=""><c path="String"/></f></toString>
		<mediatorClassName public="1"><c path="String"/></mediatorClassName>
		<mediatorClass public="1"><x path="Class"><d/></x></mediatorClass>
		<viewClass public="1"><x path="Class"><d/></x></viewClass>
		<mediatorObject public="1"><c path="mvcexpress.mvc.Mediator"/></mediatorObject>
		<viewObject public="1"><d/></viewObject>
		<new public="1" set="method" line="20"><f a="moduleName:viewObject">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="mvcexpress.core.traceobjects.messenger.TraceMessenger_addHandler" params="" file="mvcexpress/core/traceobjects/messenger/TraceMessenger_addHandler.hx">
		<extends path="mvcexpress.core.traceobjects.TraceObj"/>
		<toString public="1" set="method" line="24" override="1"><f a=""><c path="String"/></f></toString>
		<handlerClassName public="1"><c path="String"/></handlerClassName>
		<handler public="1"><d/></handler>
		<type public="1"><c path="String"/></type>
		<new public="1" set="method" line="17"><f a="moduleName:ptype:phandler:phandlerClassName">
	<c path="String"/>
	<c path="String"/>
	<d/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="mvcexpress.core.traceobjects.messenger.TraceMessenger_removeHandler" params="" file="mvcexpress/core/traceobjects/messenger/TraceMessenger_removeHandler.hx">
		<extends path="mvcexpress.core.traceobjects.TraceObj"/>
		<toString public="1" set="method" line="22" override="1"><f a=""><c path="String"/></f></toString>
		<handler public="1"><d/></handler>
		<type public="1"><c path="String"/></type>
		<new public="1" set="method" line="16"><f a="moduleName:ptype:phandler">
	<c path="String"/>
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="mvcexpress.core.traceobjects.messenger.TraceMessenger_send" params="" file="mvcexpress/core/traceobjects/messenger/TraceMessenger_send.hx">
		<extends path="mvcexpress.core.traceobjects.TraceObj"/>
		<toString public="1" set="method" line="22" override="1"><f a=""><c path="String"/></f></toString>
		<params public="1"><d/></params>
		<type public="1"><c path="String"/></type>
		<new public="1" set="method" line="16"><f a="moduleName:type:params">
	<c path="String"/>
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="mvcexpress.core.traceobjects.messenger.TraceMessenger_send_handler" params="" file="mvcexpress/core/traceobjects/messenger/TraceMessenger_send_handler.hx">
		<extends path="mvcexpress.core.traceobjects.TraceObj"/>
		<messageFromCommand public="1"><c path="mvcexpress.mvc.Command"/></messageFromCommand>
		<messageFromProxy public="1"><c path="mvcexpress.mvc.Proxy"/></messageFromProxy>
		<messageFromMediator public="1"><c path="mvcexpress.mvc.Mediator"/></messageFromMediator>
		<messageFromModule public="1"><c path="mvcexpress.core.ModuleBase"/></messageFromModule>
		<handlerClassName public="1"><c path="String"/></handlerClassName>
		<handler public="1"><d/></handler>
		<params public="1"><d/></params>
		<type public="1"><c path="String"/></type>
		<new public="1" set="method" line="29"><f a="moduleName:type:params:handler:handlerClassName">
	<c path="String"/>
	<c path="String"/>
	<d/>
	<d/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="mvcexpress.core.traceobjects.modulebase.TraceModuleBase_sendMessage" params="" file="mvcexpress/core/traceobjects/modulebase/TraceModuleBase_sendMessage.hx">
		<extends path="mvcexpress.core.traceobjects.TraceObj_SendMessage"/>
		<params public="1"><d/></params>
		<type public="1"><c path="String"/></type>
		<new public="1" set="method" line="18"><f a="moduleName:moduleObject:type:params:preSend">
	<c path="String"/>
	<c path="mvcexpress.core.ModuleBase"/>
	<c path="String"/>
	<d/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="mvcexpress.core.traceobjects.modulebase.TraceModuleBase_sendScopeMessage" params="" file="mvcexpress/core/traceobjects/modulebase/TraceModuleBase_sendScopeMessage.hx">
		<extends path="mvcexpress.core.traceobjects.TraceObj_SendMessage"/>
		<params public="1"><d/></params>
		<type public="1"><c path="String"/></type>
		<new public="1" set="method" line="18"><f a="moduleName:moduleObject:type:params:preSend">
	<c path="String"/>
	<c path="mvcexpress.core.ModuleBase"/>
	<c path="String"/>
	<d/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="mvcexpress.core.traceobjects.modulemanager.TraceModuleManager_createModule" params="" file="mvcexpress/core/traceobjects/modulemanager/TraceModuleManager_createModule.hx">
		<extends path="mvcexpress.core.traceobjects.TraceObj"/>
		<toString public="1" set="method" line="20" override="1"><f a=""><c path="String"/></f></toString>
		<autoInit public="1"><x path="Bool"/></autoInit>
		<new public="1" set="method" line="15"><f a="moduleName:autoInit">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="mvcexpress.core.traceobjects.modulemanager.TraceModuleManager_disposeModule" params="" file="mvcexpress/core/traceobjects/modulemanager/TraceModuleManager_disposeModule.hx">
		<extends path="mvcexpress.core.traceobjects.TraceObj"/>
		<toString public="1" set="method" line="18" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="14"><f a="moduleName">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="mvcexpress.core.traceobjects.modulemanager.TraceModuleManager_registerScope" params="" file="mvcexpress/core/traceobjects/modulemanager/TraceModuleManager_registerScope.hx">
		<extends path="mvcexpress.core.traceobjects.TraceObj"/>
		<toString public="1" set="method" line="26" override="1"><f a=""><c path="String"/></f></toString>
		<proxieMap public="1"><x path="Bool"/></proxieMap>
		<messageReceiving public="1"><x path="Bool"/></messageReceiving>
		<messageSending public="1"><x path="Bool"/></messageSending>
		<scopeName public="1"><c path="String"/></scopeName>
		<new public="1" set="method" line="18"><f a="moduleName:scopeName:messageSending:messageReceiving:proxieMap">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="mvcexpress.core.traceobjects.modulemanager.TraceModuleManager_unregisterScope" params="" file="mvcexpress/core/traceobjects/modulemanager/TraceModuleManager_unregisterScope.hx">
		<extends path="mvcexpress.core.traceobjects.TraceObj"/>
		<toString public="1" set="method" line="20" override="1"><f a=""><c path="String"/></f></toString>
		<scopeName public="1"><c path="String"/></scopeName>
		<new public="1" set="method" line="15"><f a="moduleName:scopeName">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="mvcexpress.core.traceobjects.proxy.TraceProxy_sendMessage" params="" file="mvcexpress/core/traceobjects/proxy/TraceProxy_sendMessage.hx">
		<extends path="mvcexpress.core.traceobjects.TraceObj_SendMessage"/>
		<params public="1"><d/></params>
		<type public="1"><c path="String"/></type>
		<new public="1" set="method" line="18"><f a="moduleName:proxyObject:type:params:preSend">
	<c path="String"/>
	<c path="mvcexpress.mvc.Proxy"/>
	<c path="String"/>
	<d/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="mvcexpress.core.traceobjects.proxy.TraceProxy_sendScopeMessage" params="" file="mvcexpress/core/traceobjects/proxy/TraceProxy_sendScopeMessage.hx">
		<extends path="mvcexpress.core.traceobjects.TraceObj_SendMessage"/>
		<params public="1"><d/></params>
		<type public="1"><c path="String"/></type>
		<new public="1" set="method" line="19"><f a="moduleName:proxyObject:type:params:preSend">
	<c path="String"/>
	<c path="mvcexpress.mvc.Proxy"/>
	<c path="String"/>
	<d/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="mvcexpress.core.traceobjects.proxymap.TraceProxyMap_injectPending" params="" file="mvcexpress/core/traceobjects/proxymap/TraceProxyMap_injectPending.hx">
		<extends path="mvcexpress.core.traceobjects.TraceObj"/>
		<toString public="1" set="method" line="28" override="1"><f a=""><c path="String"/></f></toString>
		<rule public="1"><c path="mvcexpress.core.inject.InjectRuleVO"/></rule>
		<injectObject public="1"><d/></injectObject>
		<hostObject public="1"><d/></hostObject>
		<new public="1" set="method" line="20"><f a="moduleName:hostObject:injectObject:rule">
	<c path="String"/>
	<d/>
	<d/>
	<c path="mvcexpress.core.inject.InjectRuleVO"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="mvcexpress.core.traceobjects.proxymap.TraceProxyMap_injectStuff" params="" file="mvcexpress/core/traceobjects/proxymap/TraceProxyMap_injectStuff.hx">
		<extends path="mvcexpress.core.traceobjects.TraceObj"/>
		<rule public="1"><c path="mvcexpress.core.inject.InjectRuleVO"/></rule>
		<injectObject public="1"><d/></injectObject>
		<hostObject public="1"><d/></hostObject>
		<new public="1" set="method" line="21"><f a="moduleName:hostObject:injectObject:rule">
	<c path="String"/>
	<d/>
	<d/>
	<c path="mvcexpress.core.inject.InjectRuleVO"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="mvcexpress.core.traceobjects.proxymap.TraceProxyMap_lazyMap" params="" file="mvcexpress/core/traceobjects/proxymap/TraceProxyMap_lazyMap.hx">
		<extends path="mvcexpress.core.traceobjects.TraceObj"/>
		<toString public="1" set="method" line="30" override="1"><f a=""><c path="String"/></f></toString>
		<view public="1"><c path="flash.display.DisplayObject"/></view>
		<dependencies public="1"><c path="Array"><d/></c></dependencies>
		<proxyParams public="1"><c path="Array"><d/></c></proxyParams>
		<name public="1"><c path="String"/></name>
		<injectClass public="1"><x path="Class"><d/></x></injectClass>
		<proxyClass public="1"><x path="Class"><d/></x></proxyClass>
		<new public="1" set="method" line="22"><f a="moduleName:proxyClass:injectClass:name:proxyParams">
	<c path="String"/>
	<x path="Class"><d/></x>
	<x path="Class"><d/></x>
	<c path="String"/>
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></new>
	</class>
	<class path="mvcexpress.core.traceobjects.proxymap.TraceProxyMap_map" params="" file="mvcexpress/core/traceobjects/proxymap/TraceProxyMap_map.hx">
		<extends path="mvcexpress.core.traceobjects.TraceObj"/>
		<toString public="1" set="method" line="32" override="1"><f a=""><c path="String"/></f></toString>
		<view public="1"><c path="flash.display.DisplayObject"/></view>
		<dependencies public="1"><c path="Array"><d/></c></dependencies>
		<name public="1"><c path="String"/></name>
		<injectClass public="1"><x path="Class"><d/></x></injectClass>
		<proxyObject public="1"><c path="mvcexpress.mvc.Proxy"/></proxyObject>
		<new public="1" set="method" line="24"><f a="moduleName:proxyObject:injectClass:name">
	<c path="String"/>
	<c path="mvcexpress.mvc.Proxy"/>
	<x path="Class"><d/></x>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="mvcexpress.core.traceobjects.proxymap.TraceProxyMap_scopeMap" params="" file="mvcexpress/core/traceobjects/proxymap/TraceProxyMap_scopeMap.hx">
		<extends path="mvcexpress.core.traceobjects.TraceObj"/>
		<toString public="1" set="method" line="34" override="1"><f a=""><c path="String"/></f></toString>
		<view public="1"><c path="flash.display.DisplayObject"/></view>
		<dependencies public="1"><c path="Array"><d/></c></dependencies>
		<name public="1"><c path="String"/></name>
		<injectClass public="1"><x path="Class"><d/></x></injectClass>
		<proxyObject public="1"><c path="mvcexpress.mvc.Proxy"/></proxyObject>
		<scopeName public="1"><c path="String"/></scopeName>
		<new public="1" set="method" line="25"><f a="moduleName:scopeName:proxyObject:injectClass:name">
	<c path="String"/>
	<c path="String"/>
	<c path="mvcexpress.mvc.Proxy"/>
	<x path="Class"><d/></x>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="mvcexpress.core.traceobjects.proxymap.TraceProxyMap_scopeUnmap" params="" file="mvcexpress/core/traceobjects/proxymap/TraceProxyMap_scopeUnmap.hx">
		<extends path="mvcexpress.core.traceobjects.TraceObj"/>
		<toString public="1" set="method" line="30" override="1"><f a=""><c path="String"/></f></toString>
		<view public="1"><c path="flash.display.DisplayObject"/></view>
		<dependencies public="1"><c path="Array"><d/></c></dependencies>
		<name public="1"><c path="String"/></name>
		<injectClass public="1"><x path="Class"><d/></x></injectClass>
		<scopeName public="1"><c path="String"/></scopeName>
		<new public="1" set="method" line="22"><f a="moduleName:scopeName:injectClass:name">
	<c path="String"/>
	<c path="String"/>
	<x path="Class"><d/></x>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="mvcexpress.core.traceobjects.proxymap.TraceProxyMap_scopedInjectPending" params="" file="mvcexpress/core/traceobjects/proxymap/TraceProxyMap_scopedInjectPending.hx">
		<extends path="mvcexpress.core.traceobjects.TraceObj"/>
		<toString public="1" set="method" line="30" override="1"><f a=""><c path="String"/></f></toString>
		<rule public="1"><c path="mvcexpress.core.inject.InjectRuleVO"/></rule>
		<injectObject public="1"><d/></injectObject>
		<hostObject public="1"><d/></hostObject>
		<scopeName public="1"><c path="String"/></scopeName>
		<new public="1" set="method" line="21"><f a="scopeName:moduleName:hostObject:injectObject:rule">
	<c path="String"/>
	<c path="String"/>
	<d/>
	<d/>
	<c path="mvcexpress.core.inject.InjectRuleVO"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="mvcexpress.core.traceobjects.proxymap.TraceProxyMap_unmap" params="" file="mvcexpress/core/traceobjects/proxymap/TraceProxyMap_unmap.hx">
		<extends path="mvcexpress.core.traceobjects.TraceObj"/>
		<toString public="1" set="method" line="27" override="1"><f a=""><c path="String"/></f></toString>
		<view public="1"><c path="flash.display.DisplayObject"/></view>
		<dependencies public="1"><c path="Array"><d/></c></dependencies>
		<name public="1"><c path="String"/></name>
		<injectClass public="1"><x path="Class"><d/></x></injectClass>
		<new public="1" set="method" line="20"><f a="moduleName:injectClass:name">
	<c path="String"/>
	<x path="Class"><d/></x>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="mvcexpress.mvc.Command" params="" file="mvcexpress/mvc/Command.hx">
		<canConstruct public="1" static="1"><x path="Bool"/></canConstruct>
		<getMessageType public="1" set="method" line="133">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Type of message that executed this command. (If command is not executed by message it set to null.) 
	 *</haxe_doc>
		</getMessageType>
		<unregisterScope set="method" line="121">
			<f a="scopeName">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Unregisters scope name.
	 * Then scope is not registered module to module communication via scope and mapping proxies to scope becomes not possible.</haxe_doc>
		</unregisterScope>
		<registerScope set="method" line="112">
			<f a="scopeName:?messageSending:?messageReceiving:?proxieMapping">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Registers scope name.
	 * If scope name is not registered - module to module communication via scope and mapping proxies to scope is not possible.
	 * What features module can use with that scope is defined by parameters.
	 * 
	 * 
	 * 
	 *</haxe_doc>
		</registerScope>
		<sendScopeMessage set="method" line="86">
			<f a="scopeName:type:?params">
				<c path="String"/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sends scoped module to module message, all modules that are listening to specified scopeName and message type will get it.
	 * 
	 * 
	 *</haxe_doc>
		</sendScopeMessage>
		<sendMessage set="method" line="65">
			<f a="type:?params">
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sends a message with optional params object inside of current module.</haxe_doc>
		</sendMessage>
		<isExecuting public="1"><x path="Bool"/></isExecuting>
		<messageType public="1"><c path="String"/></messageType>
		<messenger public="1">
			<c path="mvcexpress.core.messenger.Messenger"/>
			<haxe_doc>used internally for communication</haxe_doc>
		</messenger>
		<mediatorMap public="1">
			<c path="mvcexpress.core.MediatorMap"/>
			<haxe_doc>Handles application Mediators.</haxe_doc>
		</mediatorMap>
		<proxyMap public="1">
			<c path="mvcexpress.core.ProxyMap"/>
			<haxe_doc>Handles application Proxies.</haxe_doc>
		</proxyMap>
		<commandMap public="1">
			<c path="mvcexpress.core.CommandMap"/>
			<haxe_doc>Handles application Commands.</haxe_doc>
		</commandMap>
		<new public="1" set="method" line="50">
			<f a=""><x path="Void"/></f>
			<haxe_doc>CONSTRUCTOR</haxe_doc>
		</new>
	</class>
	<class path="mvcexpress.mvc.Mediator" params="" file="mvcexpress/mvc/Mediator.hx">
		<canConstruct public="1" static="1"><x path="Bool"/></canConstruct>
		<remove public="1" set="method" line="334">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* framework function to dispose this mediator. 																			<br>
	 * Executed automatically AFTER mediator is removed(unmediated). (after mediatorMap.unmediate(...), or module dispose.)					<br>
	 * It:																														<br>
	 * - remove all handle functions created by this mediator																	<br>
	 * - remove all event listeners created by internal addListener() function													<br>
	 * - sets internals to null																									<br>
	 *]]></haxe_doc>
		</remove>
		<register public="1" set="method" line="320">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* marks mediator as ready and calls onRegister()
	 * Executed automatically BEFORE mediator is created. (with proxyMap.mediate(...))</haxe_doc>
		</register>
		<removeAllListeners set="method" line="288">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Removes all listeners created by mediators addEventListener() function.
	 * WARNING: It will NOT remove events that was added normally with object.addEventListener() function.
	 * Automatically called then mediator is removed(unmediated) by framework.
	 * (You don't have to put it in mediators onRemove() function.)</haxe_doc>
		</removeAllListeners>
		<removeListener set="method" line="260">
			<f a="viewObject:type:listener:?useCapture">
				<t path="nme.events.IEventDispatcher"/>
				<c path="String"/>
				<d/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Removes an event listener from the viewObject.
	 * Then Mediator is removed(unmediated) all event handlers added with addListener() function will be automatically removed by framework.</haxe_doc>
		</removeListener>
		<addListener set="method" line="235">
			<f a="viewObject:type:listener:?useCapture:?priority:?useWeakReference">
				<t path="nme.events.IEventDispatcher"/>
				<c path="String"/>
				<d/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Registers an event listener object with viewObject, so that the listener is executed then event is dispatched.
	 * 
	 * 
	 * 
	 *   as its only parameter and must return nothing, as this example shows:
	 *   function(event:Event):void
	 *   The function can have any name.
	 * 
	 * 
	 *		If two or more listeners share the same priority, they are processed in the order in which they were added. The default priority is 0.
	 * 
	 *		A strong reference (the default) prevents your listener from being garbage-collected. A weak reference does not.</haxe_doc>
		</addListener>
		<removeScopeHandler set="method" line="213">
			<f a="scopeName:type:handler">
				<c path="String"/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Removes module to module communication handle function from message of provided type, sent to provided scopeName.
	 * 
	 * 
	 *</haxe_doc>
		</removeScopeHandler>
		<addScopeHandler set="method" line="202">
			<f a="scopeName:type:handler">
				<c path="String"/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds module to module communication handle function to be called then message of provided type is sent to provided scopeName.
	 * 
	 * 
	 *</haxe_doc>
		</addScopeHandler>
		<removeAllHandlers set="method" line="184">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Remove all handle functions created by this mediator, internal module handlers AND scoped handlers.
	 * Automatically called then mediator is removed(unmediated) by framework.
	 * (You don't have to put it in mediators onRemove() function.)</haxe_doc>
		</removeAllHandlers>
		<removeHandler set="method" line="174">
			<f a="type:handler">
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Removes handle function from message of given type.
	 * Then Mediator is removed(unmediated) all message handlers are automatically removed by framework.
	 * 
	 *</haxe_doc>
		</removeHandler>
		<addHandler set="method" line="150">
			<f a="type:handler">
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* adds handle function to be called then message of given type is sent.
	 * 
	 *</haxe_doc>
		</addHandler>
		<sendScopeMessage set="method" line="126">
			<f a="scopeName:type:?params">
				<c path="String"/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sends scoped module to module message, all modules that are listening to specified scopeName and message type will get it.
	 * 
	 * 
	 *</haxe_doc>
		</sendScopeMessage>
		<sendMessage set="method" line="105">
			<f a="type:?params">
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sends a message with optional params object inside of current module.
	 * 
	 *</haxe_doc>
		</sendMessage>
		<get_isReady set="method" line="93">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Indicates if mediator is ready for usage. (all dependencies are injected.)</haxe_doc>
		</get_isReady>
		<onRemove public="1" set="method" line="86">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Then viewObject is unmediated by this mediator - this function is called first and then mediator is removed.</haxe_doc>
		</onRemove>
		<onRegister public="1" set="method" line="79">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Then viewObject is mediated by this mediator - it is inited first and then this function is called.</haxe_doc>
		</onRegister>
		<eventListenerCaptureRegistry>
			<c path="haxe.ds.ObjectMap">
				<d/>
				<x path="Map">
					<c path="String"/>
					<t path="nme.events.IEventDispatcher"/>
				</x>
			</c>
			<haxe_doc>contains array of added event listeners, stored by event listening function as a key. For event useCapture = true</haxe_doc>
		</eventListenerCaptureRegistry>
		<eventListenerRegistry>
			<c path="haxe.ds.ObjectMap">
				<d/>
				<x path="Map">
					<c path="String"/>
					<t path="nme.events.IEventDispatcher"/>
				</x>
			</c>
			<haxe_doc>contains dictionary of added event listeners, stored by event listening function as a key. For event useCapture = false</haxe_doc>
		</eventListenerRegistry>
		<handlerVoRegistry>
			<c path="Array"><c path="mvcexpress.core.messenger.HandlerVO"/></c>
			<haxe_doc>all added message handlers.</haxe_doc>
		</handlerVoRegistry>
		<pendingInjections public="1"><x path="Int"/></pendingInjections>
		<_isReady><x path="Bool"/></_isReady>
		<messenger public="1"><c path="mvcexpress.core.messenger.Messenger"/></messenger>
		<mediatorMap public="1">
			<c path="mvcexpress.core.interfaces.IMediatorMap"/>
			<haxe_doc>* Handles application mediators.</haxe_doc>
		</mediatorMap>
		<proxyMap public="1"><c path="mvcexpress.core.interfaces.IProxyMap"/></proxyMap>
		<moduleName public="1"><c path="String"/></moduleName>
		<isReady get="accessor" set="null"><x path="Bool"/></isReady>
		<new public="1" set="method" line="59">
			<f a=""><x path="Void"/></f>
			<haxe_doc>CONSTRUCTOR</haxe_doc>
		</new>
	</class>
	<class path="mvcexpress.mvc.PooledCommand" params="" file="mvcexpress/mvc/PooledCommand.hx">
		<extends path="mvcexpress.mvc.Command"/>
		<unlock public="1" set="method" line="40">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Unlock and pool PooledCommand.
	 * Only previously locked commands can be unlocked, or error will be thrown.
	 * Command lock(), unlock() functions are used with asynchronous commands.</haxe_doc>
		</unlock>
		<lock public="1" set="method" line="31">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Locks PooledCommand to avoid automatic pooling after execution.
	 * Command lock(), unlock() functions are used with asynchronous commands.</haxe_doc>
		</lock>
		<get_isLocked public="1" set="method" line="23">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Shows if command is locked, and will not be automatically pooling after execution, or not.
	 * Asynchronous PooledCommand must be locked then used, and unlocked then they are done with there work.</haxe_doc>
		</get_isLocked>
		<_isLocked>
			<x path="Bool"/>
			<haxe_doc>* Stores information if command is locked from automatic pooling by user.</haxe_doc>
		</_isLocked>
		<isLocked public="1" get="accessor" set="null"><x path="Bool"/></isLocked>
		<new public="1" set="method" line="11"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="mvcexpress.mvc.Proxy" params="" file="mvcexpress/mvc/Proxy.hx">
		<getDependantCommands public="1" set="method" line="203"><f a=""><x path="Map">
	<d/>
	<x path="Class"><d/></x>
</x></f></getDependantCommands>
		<registerDependantCommand public="1" set="method" line="198"><f a="signatureClass">
	<x path="Class"><d/></x>
	<x path="Void"/>
</f></registerDependantCommand>
		<removeScope public="1" set="method" line="184">
			<f a="scopeName">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Remove scope for proxy to send all proxy messages to.
	 * 
	 *</haxe_doc>
		</removeScope>
		<addScope public="1" set="method" line="164">
			<f a="scopeName">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Add scope for proxy to send all proxy messages to.
	 * 
	 *</haxe_doc>
		</addScope>
		<remove public="1" set="method" line="150">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* marks mediator as not ready and calls onRemove().
	 * called from proxyMap
	 *</haxe_doc>
		</remove>
		<register public="1" set="method" line="138">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* marks mediator as ready and calls onRegister()
	 * called from proxyMap
	 *</haxe_doc>
		</register>
		<setProxyMap public="1" set="method" line="129">
			<f a="iProxyMap">
				<c path="mvcexpress.core.interfaces.IProxyMap"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* sets proxyMap interface.
	 * 
	 *</haxe_doc>
		</setProxyMap>
		<sendScopeMessage set="method" line="105">
			<f a="scopeName:type:?params">
				<c path="String"/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sends scoped module to module message, all modules that are listening to specified scopeName and message type will get it.
	 * 
	 * 
	 *</haxe_doc>
		</sendScopeMessage>
		<sendMessage set="method" line="78">
			<f a="type:?params">
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sends a message with optional params object inside of current module.
	 * 
	 *</haxe_doc>
		</sendMessage>
		<get_isReady set="method" line="66">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Indicates if proxy is ready for usage. (all dependencies are injected.)</haxe_doc>
		</get_isReady>
		<onRemove set="method" line="59">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Then proxy is unmapped with proxyMap this function is called.</haxe_doc>
		</onRemove>
		<onRegister set="method" line="52">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Then proxy is mapped with proxyMap this function is called.</haxe_doc>
		</onRegister>
		<pendingInjections public="1"><x path="Int"/></pendingInjections>
		<dependantCommands public="1"><c path="haxe.ds.ObjectMap">
	<d/>
	<x path="Class"><d/></x>
</c></dependantCommands>
		<proxyScopes><c path="Array"><c path="String"/></c></proxyScopes>
		<messenger public="1"><c path="mvcexpress.core.messenger.Messenger"/></messenger>
		<_isReady><x path="Bool"/></_isReady>
		<proxyMap>
			<c path="mvcexpress.core.interfaces.IProxyMap"/>
			<haxe_doc>* Interface to work with proxies.</haxe_doc>
		</proxyMap>
		<isReady get="accessor" set="null"><x path="Bool"/></isReady>
		<new public="1" set="method" line="41">
			<f a=""><x path="Void"/></f>
			<haxe_doc>CONSTRUCTOR</haxe_doc>
		</new>
	</class>
	<class path="mvcexpress.utils.MvcExpressTools" params="" file="mvcexpress/utils/MvcExpressTools.hx">
		<checkClassStringConstants public="1" line="15" static="1"><unknown/></checkClassStringConstants>
		<checkClassSuperClass public="1" set="method" line="17" static="1"><f a="classObject:superClass">
	<x path="Class"><d/></x>
	<x path="Class"><d/></x>
	<x path="Bool"/>
</f></checkClassSuperClass>
		<_checkClassStringConstants set="method" line="22" static="1"><f a="args">
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></_checkClassStringConstants>
	</class>
	<class path="mvcexpress.utils.StringConstantRegistry" params="" file="mvcexpress/utils/MvcExpressTools.hx" module="mvcexpress.utils.MvcExpressTools">
		<registeredClasses public="1" line="57" static="1"><x path="Map">
	<d/>
	<x path="Bool"/>
</x></registeredClasses>
		<stringRegistry public="1" line="59" static="1"><x path="Map">
	<d/>
	<c path="String"/>
</x></stringRegistry>
	</class>
	<typedef path="nme.display.MovieClip" params="" file="/usr/lib/haxe/lib/nme/4,0,2/nme/display/MovieClip.hx"><c path="flash.display.MovieClip"/></typedef>
	<typedef path="nme.display.Sprite" params="" file="/usr/lib/haxe/lib/nme/4,0,2/nme/display/Sprite.hx"><c path="flash.display.Sprite"/></typedef>
	<typedef path="nme.events.Event" params="" file="/usr/lib/haxe/lib/nme/4,0,2/nme/events/Event.hx"><c path="flash.events.Event"/></typedef>
	<typedef path="nme.events.IEventDispatcher" params="" file="/usr/lib/haxe/lib/nme/4,0,2/nme/events/IEventDispatcher.hx"><c path="flash.events.IEventDispatcher"/></typedef>
	<class path="suites.general.GeneralTests" params="" file="test/suites/general/GeneralTests.hx">
		<general_debug_flag public="1" set="method" line="26"><f a=""><x path="Void"/></f></general_debug_flag>
		<general_framework_version public="1" set="method" line="18"><f a=""><x path="Void"/></f></general_framework_version>
		<new public="1" set="method" line="12"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="utils.Assert" params="" file="test/utils/Assert.hx">
		<assertEquals public="1" line="9" static="1"><f a="::">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></assertEquals>
		<assertStrictlyEquals public="1" line="10" static="1"><unknown/></assertStrictlyEquals>
		<assertTrue public="1" line="11" static="1"><f a=":">
	<c path="String"/>
	<x path="Bool"/>
	<unknown/>
</f></assertTrue>
		<assertFalse public="1" line="12" static="1"><f a=":">
	<c path="String"/>
	<x path="Bool"/>
	<unknown/>
</f></assertFalse>
		<assertNull public="1" line="13" static="1"><unknown/></assertNull>
		<assertNotNull public="1" line="14" static="1"><f a=":">
	<c path="String"/>
	<c path="mvcexpress.core.ProxyMap"/>
	<unknown/>
</f></assertNotNull>
		<assertUndefined public="1" line="15" static="1"><unknown/></assertUndefined>
		<assertNotUndefined public="1" line="16" static="1"><unknown/></assertNotUndefined>
		<_assertEquals public="1" set="method" line="22" static="1"><f a="rest">
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></_assertEquals>
		<failNotEquals public="1" set="method" line="28" static="1"><f a="message:expected:actual">
	<c path="String"/>
	<d/>
	<d/>
	<x path="Void"/>
</f></failNotEquals>
		<_assertStrictlyEquals set="method" line="33" static="1"><f a="rest">
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></_assertStrictlyEquals>
		<failNotStrictlyEquals public="1" set="method" line="39" static="1"><f a="message:expected:actual">
	<c path="String"/>
	<d/>
	<d/>
	<x path="Void"/>
</f></failNotStrictlyEquals>
		<_assertTrue public="1" set="method" line="44" static="1"><f a="rest">
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></_assertTrue>
		<failNotTrue public="1" set="method" line="50" static="1"><f a="message:condition">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></failNotTrue>
		<_assertFalse public="1" set="method" line="55" static="1"><f a="rest">
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></_assertFalse>
		<failTrue public="1" set="method" line="61" static="1"><f a="message:condition">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></failTrue>
		<_assertNull public="1" set="method" line="66" static="1"><f a="rest">
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></_assertNull>
		<failNull public="1" set="method" line="72" static="1"><f a="message:object">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></failNull>
		<_assertNotNull public="1" set="method" line="77" static="1"><f a="rest">
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></_assertNotNull>
		<failNotNull public="1" set="method" line="83" static="1"><f a="message:object">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></failNotNull>
		<_assertUndefined public="1" set="method" line="89" static="1"><f a="rest">
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></_assertUndefined>
		<failUndefined public="1" set="method" line="96" static="1"><f a="message:object">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></failUndefined>
		<_assertNotUndefined public="1" set="method" line="102" static="1"><f a="rest">
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></_assertNotUndefined>
		<failNotUndefined public="1" set="method" line="109" static="1"><f a="message:object">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></failNotUndefined>
		<fail public="1" set="method" line="114" static="1"><f a="?failMessage">
	<c path="String"/>
	<x path="Void"/>
</f></fail>
		<failWithUserMessage public="1" set="method" line="119" static="1"><f a="userMessage:failMessage">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></failWithUserMessage>
		<new public="1" set="method" line="18"><f a=""><x path="Void"/></f></new>
	</class>
</haxe>